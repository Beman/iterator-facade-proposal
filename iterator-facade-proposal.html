<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Iterator Facade - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="data:text/css;charset=utf-8,body%0A%7B%0Afont%2Dfamily%3A%20arial%2C%20sans%2Dserif%3B%0Amax%2Dwidth%3A%206%2E5in%3B%0Amargin%3A%200px%20auto%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ains%20%7Bbackground%2Dcolor%3A%20%23CCFFCC%3B%20text%2Ddecoration%3A%20none%3B%7D%0Adel%20%7Bbackground%2Dcolor%3A%20%23FFCACA%3B%20text%2Ddecoration%3A%20none%3B%7D%0Apre%20%7Bbackground%2Dcolor%3A%20%23D7EEFF%3B%20font%2Dsize%3A%2095%25%3B%20font%2Dfamily%3A%20%22courier%20new%22%2C%20courier%2C%20serif%3B%7D%0Acode%20%7Bfont%2Dsize%3A%20110%25%3B%20font%2Dfamily%3A%20%22courier%20new%22%2C%20courier%2C%20serif%3B%7D%0Atable%20%7Bfont%2Dsize%3A%2090%25%3B%7D%0A%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">D0186R0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left"><span style="background-color:yellow">2016-02-09</span></td>
</tr>
<tr>
  <td align="left" valign="top">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;</br>
  Eric Niebler &lt;eric dot niebler at gmail dot com&gt;</br>
  Casey Carter &lt;casey at carter dot net&gt;</td></tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>
<!-- generate-section-numbers=false -->
<p><span style="background-color:yellow"><em>TODO List</em></span></p>
<ul>
<li><code>basic_iterator</code> iter_move, iter_swap need descriptions.</li>
<li>24.8.9.3.2 Requirements [basic_iterator.require] Needs more work</li>
<li>Need review of <code>basic_iterator</code> function descriptions against the current cmcstl2 codebase.</li>
</ul>
<h1 id="iterator-facade-library-proposal-for-ranges">Iterator Facade Library Proposal for Ranges</h1>
<p><em>&quot;We are what we pretend to be, so we must be careful about what we pretend to be.&quot; - Kurt Vonnegut</em></p>
<h2 id="summary">Summary</h2>
<p>Proposes a library component for easily creating conforming iterators. Based on existing practice. Depends only on the C++17 working paper plus Concepts TS and Ranges TS. Breaks no existing code or ABI's. Two open-source implementations including test suites available. Proposed wording provided.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<!-- include "toc.html" --><a href="#iterator-facade-library-proposal-for-ranges">Iterator Facade Library Proposal for Ranges</a><br>
<a href="#summary">Summary</a><br>
<a href="#table-of-contents">Table of Contents</a><br>
<a href="#introduction">Introduction</a><br>
&nbsp;&nbsp;&nbsp;<a href="#problem">Problem</a><br>
&nbsp;&nbsp;&nbsp;<a href="#solution">Solution</a><br>
&nbsp;&nbsp;&nbsp;<a href="#proposal">Proposal</a><br>
&nbsp;&nbsp;&nbsp;<a href="#history">History</a><br>
<a href="#example">Example</a><br>
<a href="#design-decisions">Design Decisions</a><br>
&nbsp;&nbsp;&nbsp;<a href="#use-boost-iterator_facade-as-a-role-model">Use Boost <code>iterator_facade</code> as a role model</a><br>
&nbsp;&nbsp;&nbsp;<a href="#base-design-on-concepts-and-ranges">Base design on Concepts and Ranges</a><br>
&nbsp;&nbsp;&nbsp;<a href="#use-cursor-mixins-to-supply-details">Use Cursor mixins to supply details</a><br>
<a href="#proposed-wording">Proposed wording</a><br>
&nbsp;&nbsp;&nbsp;<a href="#basic-iterators-iterators.basic">24.8.9  Basic Iterators </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cursors-cursor.intro">24.8.9.1  Cursors </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#namespace-cursor-synopsis-cursor.synopsis">24.8.9.1.1  Namespace cursor synopsis </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cursor-traits-cursor.traits">24.8.9.1.2  Cursor traits </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#single_pass-cursor.single">24.8.9.1.2.1  <code>single_pass</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#contiguous-cursor.contig">24.8.9.1.2.2  <code>contiguous</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#types-cursor.types">24.8.9.1.2.3  Types </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#concepts-cursor.concepts">24.8.9.1.3  Concepts </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#class-template-basic_mixin-iterator.mixin">24.8.9.2  Class template <code>basic_mixin</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#constructors-mixin.cons">24.8.9.2.1  Constructors </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#t-object-access-mixin.access">24.8.9.2.2  <code>T</code> object access </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#class-template-basic_iterator-iterator.basic_iterator">24.8.9.3  Class template <code>basic_iterator</code> </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#synopsis-basic_iterator.synopsis">24.8.9.3.1  Synopsis </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#requirements-basic_iterator.require">24.8.9.3.2  Requirements </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#constructors-assignments-and-moves-basic_iterator.cons">24.8.9.3.3  Constructors, assignments, and moves </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dereferences-basic_iterator.deref">24.8.9.3.4  Dereferences </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#modifiers-basic_iterator.mods">24.8.9.3.5  Modifiers </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#basic_iterator-nonmember-functions-basic_iterator.nonmem">24.8.9.3.6  <code>basic_iterator</code> nonmember functions </a><br>
<a href="#open-questions">Open questions</a><br>
<a href="#acknowledgements">Acknowledgements</a><br>
<a href="#references">References</a><br><!-- end include -->
<h2 id="introduction">Introduction</h2>
<h3 id="problem">Problem</h3>
<p>Iterators that conform to the requirements of the C++ standard library are tedious to write and difficult to write correctly. They are tedious to write because although they need only a few core functions, they also need subsidiary types, functions, and other boilerplate. Conforming iterators are difficult to write correctly because each iterator category has a subtly differing set of requirements, making it all too easy to get subsidiary types, functions, or other boilerplate wrong.</p>
<h3 id="solution">Solution</h3>
<p>A class template that is given a few implementation functions can generate the facade (i.e. public interface and private implementation) for a fully conforming iterator, including all boilerplate. Boost <code>iterator_facade</code> pioneered this approach and has been in wide use since 2001<sup>[<a href="#1">1</a>]</sup>. It eases writing conforming iterators and has proven less error prone than hand-coded iterators. The generated iterator conforms to an extended set of requirements based on the C++98 iterator requirements. Others, such as Chandler Carruth's LLVM <code>iterator_facade_base</code><sup>[<a href="#2">2</a>]</sup>, have provided similar classes inspired by the Boost library.</p>
<h3 id="proposal">Proposal</h3>
<p>This paper proposes an iterator facade class template for the standard library, useful by any programmer (novice, experienced, or expert) wishing to easily create a conforming iterator. The proposal uses C++11/14/17 with concepts<sup>[<a href="#3">3</a>]</sup> and ranges<sup>[<a href="#4">4</a>]</sup> to allow straightforward specification and implementation, and to ensure that the generated iterator is actually conforming. The proposal breaks no existing code and breaks no existing ABI's. Two open-source implementations with test suites are available on GitHub<sup>[<a href="#5">5</a>][<a href="#6">6</a>]</sup>.</p>
<p>The proposal is suitable for C++17 if C++17 includes concepts and ranges. Otherwise, the proposal is suitable for the Ranges TS. No other core language or library changes are required.</p>
<h3 id="history">History</h3>
<p>A 2004 proposal<sup>[<a href="#7">7</a>]</sup> based on Boost <code>iterator_facade</code> failed because it depended on an iterator update proposal<sup>[<a href="#8">8</a>]</sup> that failed because without concepts the language was not rich enough to express the necessary iterator requirements.</p>
<h2 id="example">Example</h2>
<pre><!-- include "word_iterator.cpp" formatted snippet=word_iterator -->class cursor
{
  using string = std::string;
  const string* str_;        // nullptr if uninitialized
  string::size_type begin_;  // end iterator: begin_ == string::npos
  string word_;
  static constexpr const char* alpha =
    &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
 public:
  cursor() noexcept
    : str_(nullptr), begin_(string::npos), word_() {}
  cursor(const string&amp; str)
    : str_(&amp;str), begin_(0), word_() { next(); }
  const string&amp; read() const noexcept {
    assert(str_);                    // fails if uninitialized
    assert(begin_ != string::npos);  // fails on dereference end
    return word_;
  }
  bool equal(const cursor&amp; rhs) const noexcept
    { return begin_ == rhs.begin_; }
  void next() {
    assert(str_);                    // fails if uninitialized
    assert(begin_ != string::npos);  // fails on increment past end
    if ((begin_ += word_.size()) != string::npos
        &amp;&amp; (begin_ = str_-&gt;find_first_of(alpha, begin_)) != string::npos)
      word_.assign(*str_, begin_,
        str_-&gt;find_first_not_of(alpha, begin_) - begin_);
  }
};

using word_iterator = ranges::basic_iterator&lt;cursor&gt;;<!-- end include --></pre>
<p>The five member functions in class <code>cursor</code> result in generation of approximately eleven class <code>word_iterator</code> functions, as well supply in several useful iterator type-traits.</p>
<p>For a sample program that uses <code>word_iterator</code>, <a href="#basic-iterators-iterators.basic">see Basic Iterators, below</a>.</p>
<h2 id="design-decisions">Design Decisions</h2>
<h3 id="use-boost-iterator_facade-as-a-role-model">Use Boost <code>iterator_facade</code> as a role model</h3>
<p>This ensures that the proposal represents existing practice in widespread use.</p>
<h3 id="base-design-on-concepts-and-ranges">Base design on Concepts and Ranges</h3>
<p>This eliminates the difficulties with specification that bedeviled the 2004 proposal. It allows a concepts based interface specification that ensures the resulting iterator is actually conforming. It improves error message quality when the user makes a mistake. Using concepts based overloading eliminates the need for the implementation to perform complex template meta-programming.</p>
<h3 id="use-cursor-mixins-to-supply-details">Use Cursor mixins to supply details</h3>
<p>Cursor mixins have proven themselves useful time and again. That said, it's a curiously indirect way of defining an iterator's interface. The alternative of inheriting directly from the Cursor leads to interface pollution. Cursors are implementation details and they should stay hidden.</p>
<h2 id="proposed-wording">Proposed wording</h2>
<!-- generate-section-numbers -->
<p><span style="background-color:lightgrey"><em>Editorial comments are shown in italics with a light grey background.</em></span></p>
<p><span style="background-color:lightgrey"><em>Proposed wording is relative to the Working Draft, C++ Extensions for Ranges</em></span></p>
<p><span style="background-color:lightgrey"><em>Namespace qualification in the form <code>ranges::</code> is used as a placeholder pending a decision as to the final target for this proposal. If the target is the Ranges TS, <code>ranges::</code> will be replaced editorially by <code>std::experimental::ranges::</code>. If the target is the standard itself, <code>ranges::</code> will be replaced by <code>std::</code>, assuming the standard library itself does not introduce namespace versioning.</em></span></p>
<p><span style="background-color:lightgrey"><em>Add the following proposed wording as a new Iterator adapter at the end of 24.8 Iterator adaptors [iterators.predef]:</em></span></p>
<h3 id="basic-iterators-iterators.basic">24.8.9  Basic Iterators [iterators.basic]</h3>
<p>Class template <code>basic_iterator</code> (<a href="#class-template-basic_iterator-iterator.basic_iterator">iterator.basic_iterator</a>) is an iterator adaptor that iterates over a sequence provided by a cursor type. [<em>Note:</em> <code>basic_iterator</code> eases creation of conforming iterators because cursors are simpler to create than iterators. <em>-- end note</em>] Cursors are implementation details of a <code>basic_iterator</code> instantiation that are encapsulated as mixins so that they are hidden from users of the instantiation.</p>
<p>[<em>Example:</em></p>
<pre><!-- include "word_iterator.cpp" formatted snippet=word_iterator -->class cursor
{
  using string = std::string;
  const string* str_;        // nullptr if uninitialized
  string::size_type begin_;  // end iterator: begin_ == string::npos
  string word_;
  static constexpr const char* alpha =
    &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
 public:
  cursor() noexcept
    : str_(nullptr), begin_(string::npos), word_() {}
  cursor(const string&amp; str)
    : str_(&amp;str), begin_(0), word_() { next(); }
  const string&amp; read() const noexcept {
    assert(str_);                    // fails if uninitialized
    assert(begin_ != string::npos);  // fails on dereference end
    return word_;
  }
  bool equal(const cursor&amp; rhs) const noexcept
    { return begin_ == rhs.begin_; }
  void next() {
    assert(str_);                    // fails if uninitialized
    assert(begin_ != string::npos);  // fails on increment past end
    if ((begin_ += word_.size()) != string::npos
        &amp;&amp; (begin_ = str_-&gt;find_first_of(alpha, begin_)) != string::npos)
      word_.assign(*str_, begin_,
        str_-&gt;find_first_not_of(alpha, begin_) - begin_);
  }
};

using word_iterator = ranges::basic_iterator&lt;cursor&gt;;<!-- end include --></pre>
<p>Program using <code>word_iterator</code>:</p>
<pre><!-- include "word_iterator.cpp" formatted snippet=word_iterator_use -->int main()
{
  std::string s
    (&quot;now is 2016 the  time   when\nall good programmers should-party.&quot;);

  for (word_iterator it(s); it != word_iterator(); ++it)
    std::cout &lt;&lt; *it &lt;&lt; &quot; (&quot; &lt;&lt; it-&gt;size() &lt;&lt; &quot;)\n&quot;;
}<!-- end include --></pre>
<p>When executed, the output is:</p>
<blockquote>
<pre>
now (3)
is (2)
the (3)
time (4)
when (4)
all (3)
good (4)
programmers (11)
should (6)
party (5)</pre>
</blockquote>
<p><em>-- end example</em>]</p>
<p>A cursor <code>C</code> may extend the interface of <code>basic_iterator&lt;C&gt;</code> by defining a nested mixin type <code>C::mixin</code>. In that way, the author of a cursor can non-intrusively add members and constructors to <code>basic_iterator</code>. If a cursor does not define a nested mixin type, a default mixin type will be provided.</p>
<blockquote>
<p>[<em>Note:</em> By publicly inheriting from a mixin type parameterized by the cursor type, <code>basic_iterator</code> gets access to the cursor object, and, optionally, additional members such as constructors. <em>-- end note</em>]</p>
</blockquote>
<p>This sub-clause has three major sub-sections:</p>
<ul>
<li><a href="#namespace-cursor">Namespace <code>cursor</code></a> describes cursor types.</li>
<li><a href="#iterator-mixin">Class template <code>basic_mixin</code></a> describes mixin types.</li>
<li><a href="#basic_iterator">Class template <code>basic_iterator</code></a> describes <code>basic_iterator</code>.</li>
</ul>
<h4 id="cursors-cursor.intro">24.8.9.1  Cursors [cursor.intro]</h4>
<p>Namespace <code>cursor</code> provides a scope for the type traits, concepts, and other traits needed to describe cursor types.</p>
<p>Which cursor concepts are satisfied by a user-supplied cursor type is determined by its members. The relationship between a cursor type's member, the cursor concept that requires it, and a summary of the cursor concept's requirement for the member are shown by the following table. The table is informational; actual requirements are specified by the concept descriptions that follow.</p>
<!-- include "mapping.html" snippet=table --><table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td align="center"><b><i>Member<br>
    name</i></b></td>
    <td align="center"><b><i>Required by<br>
    Concept</i></b></td>
    <td align="center"><i><b>Cursor member requirement summary</b></i></td>
  </tr>
  <tr>
    <td><code>read</code></td>
    <td><code>Readable&lt;C&gt;</code></td>
    <td><code>requires(const C&amp; c)
&nbsp; {{c.read()} -&gt; auto&amp;&amp;;
&nbsp;&nbsp;&nbsp; typename reference_t&lt;C&gt;;
&nbsp;&nbsp;&nbsp; typename value_type_t&lt;C&gt;;}</code></td>
  </tr>
  <tr>
    <td><code>arrow</code></td>
    <td><code>Arrow&lt;C&gt;</code></td>
    <td><code>requires(const C&amp; c)
     {{c.arrow()} -&gt; auto&amp;&amp;;}</code></td>
  </tr>
  <tr>
    <td><code>next</code></td>
    <td><code>Next&lt;C&gt;</code></td>
    <td><code>requires(C&amp; c) {c.next();}</code></td>
  </tr>
  <tr>
    <td><code>prev</code></td>
    <td><code>Prev&lt;C&gt;</code></td>
    <td><code>requires(C&amp; c) {c.prev();}</code></td>
  </tr>
  <tr>
    <td><code>indirect_move</code></td>
    <td><code>IndirectMove&lt;C&gt;</code></td>
    <td><code>requires(const C&amp; c)
     {c.indirect_move();}</code></td>
  </tr>
  <tr>
    <td><code>indirect_swap</code></td>
    <td><code>IndirectSwap&lt;C1,
 C2&gt;</code></td>
    <td><code>requires(const C1&amp; c1, const C2&amp; c2)</code>
    <code>&nbsp; {c1.indirect_swap(c2);
&nbsp;&nbsp; c2.indirect_swap(c1);}</code></td>
  </tr>
  <tr>
    <td><code>advance</code></td>
    <td><code>Advance&lt;C&gt;</code></td>
    <td><code>requires(C&amp; c, difference_type_t&lt;C&gt; n)
&nbsp; {c.advance(n);}</code></td>
  </tr>
  <tr>
    <td><code>write</code></td>
    <td><code>Writable&lt;C, T&gt;</code></td>
    <td><code>requires(C&amp; c, T&amp;&amp; t)
&nbsp; {c.write(range::forward&lt;T&gt;(t));}</code></td>
  </tr>
  <tr>
    <td><code>distance_to</code></td>
    <td><code>SizedSentinel&lt;S,
 C&gt;</code></td>
    <td><code>requires(const C&amp; c, const S&amp; s)
&nbsp; {{c.distance_to(s)} -&gt;
    Same&lt;difference_type_t&lt;C&gt;;}</code></td>
  </tr>
  <tr>
    <td><code>equal</code></td>
    <td><code>Sentinel&lt;S, C&gt;</code></td>
    <td><code>requires(const C&amp; c, const S&amp; s)
&nbsp; {{c.equal(s)}-&gt;bool;}</code></td>
  </tr>
  <tr>
    <td><code>single_pass::value</code></td>
    <td><code>Forward&lt;C&gt;</code></td>
    <td><code>bool single_pass::value&nbsp; </code><br>default: <code>=false</code></td>
  </tr>
  <tr>
    <td><code>contiguous::value</code></td>
    <td><code>Contiguous&lt;C&gt;</code></td>
    <td><code>is_reference&lt;reference_t&lt;C&gt;&gt;::value </code><br>default: <code>=false</code></td>
  </tr>
  <tr>
    <td><code>mixin</code></td>
    <td><code>Cursor&lt;C&gt;</code></td>
    <td><code>type mixin&nbsp; </code><br>default: <code>=basic_mixin&lt;C&gt;</code></td>
  </tr>
  <tr>
    <td><code>value_type</code></td>
    <td><code>Readable&lt;C&gt;</code></td>
    <td><code>type value_type&nbsp; </code><br>default: <code>=decay_t&lt;reference_t&lt;C&gt;&gt;</code></td>
  </tr>
  </table><!-- end include -->
<p>Cursor members shown with defaults are only required if the default is not appropriate.</p>
<p>The following figure shows the relationship between cursor related concepts. The figure is informational; actual relationships are specified by the concepts descriptions that follow.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAOSCAIAAAA6Qu1yAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdeXwTZeLH8aQntCgWXDlUdpWrCEXZcshR5ChacCug22JBuwgreBcRthU8iqvYCsKP9UDQBZZ1oRalBarIoVwtKloQwQJyCSgIFmq5e+b3R9xszEwmk2SSZyb5vP/wJelk5juTtMk3z8wTs8ViMQEAAAAAAH0LER0AAAAAAAC4RoEHAAAAAMAAwkQHAADAQ7t27aqurhadAvCViIiIuLg40SkAADpCgQcAGNLXX3/dvXv366+/XnQQwFeOHTv2xRdfdOnSRXQQAIBeUOABAIZ08eLF3//+9/v37xcdBPCVdu3aXbx4UXQKAICOcA08AAAAAAAGQIEHAAAAAMAAKPAAAAAAABgABR4AAAAAAAOgwAMAAAAAYAAUeAAAAp/ZbBYdAQAAeIuvkQMAwCfsO7PFYrHeYv0fbbei+TqNzj9HHgAA/6PAAwCgPYfGKHwAPFDrq7SZKx95mjwAwNA4hR4AAI1JW6LFYqE3as5lezdJjrzFYhH+YQoAAB5jBB4AAC0pjPFK26bLn9oXTmd3V1iP9GRyZ5lty9i26xBDNpua3fFmDc4OprO7qzny0n0EAMAoKPAAAAjgcvTY2jPtb5QuILseew4t2mUSabOVHbKW3qiwO96sQTatyevubTt03q8KAAB/4hR6AAD8TbZ1Oyu6ygtom8SzNqt+d9wiXad1Q1pVbuuqOKMeAGAgjMADAADxpF3avqv7brScM+oBAAZCgQcAALqgcE0B38MHAICJU+gBAIA+yY7JW+cF0GT9DlMMAACgfxR4AAC0pHBZNZdbK1B5cGwXrquZGM/Zym3VnfYOADAWCjwAABqTbZIOJ4QrL+AxdweoHZKovK/swLh0GTVfXKdwo/LXwqmc3F66Hqo7AMC4uAYeAADtyZ7+7dYC1p9Kv+NN9tvmZFci7cOyizl81byaViz9ijvl3VGzBuV9kSX7RfHKSThnHgBgaBR4AAB8Qk3/dOunCsPRngVQv6SaMF7uju1L45WTqNmowkpo7wAAQ+MUegAAAAAADIACDwAAfsUZ5gAA6Bmn0AMAENTcuuwcAAAIRIEHACCoUdoBADAKTqEHAAAAAMAAKPAAAAAAABgABR4AAAAAAAOgwAMAAAAAYABMYgcAgJ/wJW0GxUT9AACdoMADAKAByrkDaek17iGyxbbfKQAA/I8CDwCAnxi0vqrhUM6l/1ReHgAAqME18AAAwCvK7d1kMlksFuktjGYDAOAuRuABAAHOoShaq6PC+LBD1bT+1L5wyi6gsB71V1Dbb8K2XfsMssGcrUQ2hpqVuDxiCndXGFp31uEVjomzY+5yGWfHXPZ25SeAMo8fGk5AAAB4gAIPAAhk0j7p0NZkF7C/xdoz7W+ULiC7HocFpJtWiOrQAGXHq2VvVNgdlStxecRkE3pG4eMJLzl7UGQ/vlF+ArjckGcPDRcRAAA8wCn0AICAJduRXJYoZ5VMeQEvyX4o4OVKbKvyMq3sSLL0rHhv1u+jM+rVfDzhnxbt7KMEP2waABBIGIEHAAQdRj4VSIulfVf3xWi5w3bd/SCDRxMAEDwo8AAA4DcUTin33RfCCTyl3D8j4Yy3AwC8R4EHAABKpNeNq5l/Tj3fjeqbfhte9jMCldf8a5LEF6sFAAQVCjwAIOgwf5gClQfH2fxzylPWq5yt3WEB75dRuC/PBACAgTCJHQAgYLmcDFzlRO4esE5cr355hyRq7uvxvPTKK5HeqDzBvuw18+qnx/dDf5Z+j4ACTYbf1T803m8LABBUGIEHAAQy2Xrp1gLWn0q/483ZWeUOK5GWYTVJ1LRi2V6qvDuercRl71U4x97ZSnQy9K3mgLh8BDV5aAAAUIMCDwAIcGr6p1s/VRiO9mDrmifxciW2UqqwEo+zqfypW4t5uYzKA+Lu+r1/MgAAIMUp9AAAAAAAGAAFHgAA3dHJGeYAAEBXOIUeAABdcOuycwAAEIQo8AAA6AKlHQAAKOMUegAAAAAADIACDwAAAACAAVDgAQAAAAAwAAo8AAAAAAAGQIEHAAAAAMAAmIUeAGBIV1555YEDB+y/eg0IMBEREU2bNhWdAgCgI2a+tAYAYFC//PILr2J+c/Hixeuuu+6HH36IiooSnSVYhIWFXXHFFaJTAAB0hAIPAABcu3DhQqNGjc6fPx8dHS06CwAAQYpr4AEAAAAAMAAKPAAAAAAABkCBBwAAAADAACjwAAAAAAAYAAUeAAAAAAADoMADAAAAAGAAFHgAAAAAAAyAAg8AAAAAgAFQ4AEAAAAAMAAKPAAAAAAABkCBBwAAAADAACjwAAAAAAAYAAUeAAAAAAADoMADAAAAAGAAFHgAAAAAAAyAAg8AAAAAgAFQ4AEAAAAAMAAKPAAAAAAABkCBBwAAAADAACjwAAAAAAAYAAUeAAAAAAADoMADAAAAAGAAFHgAAAAAAAyAAg8AAAAAgAFQ4AEAAAAAMACzxWIRnQEAAOhURkbG6tWrTSaTxWL56aefmjdvbjabTSbT4MGD58yZIzodAADBJUx0AAAAoF+nTp06ePBgfX299Z8HDhwwmUwhISGnTp0SmgsAgGDEKfQAAMCpMWPGNGjQwOHGhg0bjhkzRkgeAACCGafQAwAAp+rq6q6++upffvnF/sarrrqqvLw8NDRUVCoAAIITI/AAAMCp0NDQkSNHhoeH224JDw8fOXIk7R0AAP+jwAMAACX333+/fV0PDQ29//77BeYBACBocQo9AABwoWXLlidOnLD9/48//ig2DwAAwYkReAAA4MLo0aMjIyNNJlNkZOTo0aNFxwEAIEhR4AEAgAv333+/9ZQ9i8XC+fMAAIhCgQcAAC506NDhuuuuM5lM119/fWxsrOg4AAAEKQo8AABw7YEHHrD9FwAACMEkdgAA/M/06dP/+c9/ik6hRzU1NceOHWvVqlVYWJjoLHo0duzYKVOmiE4BAAhwvAYDAPA/27dvT01N/fOf/yw6iB6dPn26adOmolPo0QcffFBaWio6BQAg8FHgAQD4jVatWsXHx4tOASP58ssv9+3bJzoFACDwcQ08AAAAAAAGQIEHAAAAAMAAKPAAAAAAABgABR4AAAAAAAOgwAMAAAAAYAAUeAAAAAAADIACDwAAAACAAVDgAQAAAAAwAAo8AAAAAAAGQIEHAMAYzGaz2WwWnQIAAAgTJjoAAABGIluhLRaLHzZtsVg0L/AOK/TPjghnv9fWXTabzUGy7wAAQ6PAAwDgBtm+Z9z6Z4sdwGP7yg+Ww44b96EEAAQDTqEHAMBbvhgb9ydrazX6Xshy+VGLdcft/xl4BwEAEDAYgQcAwCcUzk63/si+K8qO+krP9PZmK7ZzBxTWpkC6IeWhbOUFXO6vZ5uQrk3liRKyHZ6heACA3lDgAQDQnrQr2t9irYj2tygvb3JyirtbW3Go8W61U9kNebOAy/31YBMOt3tTv738sAMAAB/hFHoAALwle2K2y3spnLnt8kxv2WWk65FuRTm87AnkzjbkzQJqzlR3eQwVdkeT1h2olxUAAIyLEXgAADyh5vz2wOZZwVZYWPrRg/LV6Q4L+GjAnDPqAQD6QYEHAMATLoegDTFyaw3ph5nY1RwNl6cYKC/goy+EY156AIB+UOABAPCW7HRrKi/YFs4/Hz140IGV56hztoCGA+YMvAMA9IZr4AEA0FiQjNm67PlufRCg4dps167LzlqvZuW2yf+C4XEEABgIBR4AAA0oz3bm7pi2dG0q66hbnx04W9hhzS435PECyrd4MC+9w17IXjbv8qBR3QEAusUp9AAAuMFW/5xd967QGx2+0c3ha+RMiqXXdkflYiyd1M3Zl9XZX/0uvZdyGJPkxHLvF3C2y24tICU9zd7lQaO6AwB0iwIPAIAblId8FRZT/1O3FlOZx2UAlz/yfs555QWsP3UZzLNr6dUnob0DAPSMU+gBAAAAADAACjwAAAAAAAZAgQcAAAAAwAAo8AAAAAAAGAAFHgAAAAAAA6DAAwAAAABgABR4AAAAAAAMgAIPAAAAAIABUOABAAAAADAACjwAAAAAAAZAgQcAAAAAwAAo8AAAAAAAGAAFHgAAAAAAAwgTHQAAAH155513NmzY4OyntbW1Z86cqaysbNu2rT9TBZva2tqqqqro6GjRQVQ5ePDgDTfcIDoFACDwmS0Wi+gMAADoRWlpaWlpqcONp0+fPnjw4KFDhw4cOPDjjz9effXVN954Y3p6emhoqJCQQlRVVT3xxBP/+Mc/IiMj/bC5vXv3zp07t0ePHkOGDLnqqqv8sEUv9evXr127dqJTAAACHAUeAABHlZWVmzdvLi0tLSkp2bZtW2hoaO/evfv06dO7d++bb775iiuuEB1QgAsXLjRq1Oj8+fN+GxUvLy+fOXPmm2++mZaW9vzzz7ds2dI/2wUAQLco8AAAmEwm06FDh4qLi0tKSoqLi7/77rt27dpZG3t8fHxsbGxQDbbL8n+Btzp27NiLL76Yl5c3evToqVOnXnPNNf7cOgAAukKBBwAEqaqqqi+//NLa2EtLSysqKuLj462lvVu3bs2bNxcdUF9EFXirvXv3Tp8+feXKlQ899NDTTz/duHFj/2cAAEA4CjwAIIiUl5dv2LDB2th37NjRqFGj2267zXp6fOfOncPDw0UH1C+xBd5q9+7dL7zwwoYNGyZNmvTEE080bNhQVBIAAISgwAMAApnFYtm+fbu1sZeUlHz//fddunSxXdDOZdXq6aHAW3322WdTp07dv3//s88+O2bMmLAwvlIHABAsKPAAgEBz8eLFrVu3Wi9o37ZtW0hISJ8+fYJ8Cjrv6afAW61fv/7pp58uLy9/+umnx44dyyQFAIBgQIEHAASCw4cPb9myxX4KOtsF7UxBpwm9FXir9evXT5o0qba29vnnn//zn/9sNptFJwIAwIco8AAAQ6qurt62bZttCrozZ8507drV2ti7du3aokUL0QEDjT4LvMlkqq+v/+CDD6ZMmdK0adOXXnpp4MCBohMBAOArFHgAgGHYT0H39ddfR0VF9evXjyno/EO3Bd6qpqZm4cKF06ZNu+GGG15++eWEhATRiQAA0B4FHgCgXxaLpayszDrMzhR0Yum8wFtdvHjx7bffnj59eufOnV955ZUuXbqITgQAgJYo8AAAfbl06ZKtsdumoLNe0N6jRw+moBPFEAXe6vz582+88UZOTs6gQYNeeumltm3bik4EAIA2KPAAAPGYgk7/DFTgrU6fPj1jxoy5c+cOHTrUemq96EQAAHiLAg8AEIAp6AzHcAXe6ocffpgxY8bChQvT0tKmTZvWvHlz0YkAAPAcBR4A4CenT5/eunWrtbQzBZ3hGLTAWx05cmT69Ol5eXkPP/xwVlbWVVddJToRAACeoMADAHzF2RR01tPjb7zxRtEB4QZDF3irsrKy7OzsTz/9dPLkyY8//nhUVJToRAAAuIcCDwDQElPQBaoAKPBW27Ztmzp16s6dO5966qkJEyZERkaKTgQAgFoUeACAt77//vvNmzczBV1gC5gCb1VcXDx16tTvv/9+6tSpY8eO5VkKADAECjwAwG3WKehKS0utpZ0p6IJBgBV4k8lUX1+/bNmy5557Ljo6evr06UlJSaITAQDgAgUeAKCKwxR0DRs27N+/v/WC9j/+8Y9cThzwAq/AW9XW1i5atGjatGlt27Z9+eWXe/ToIToRAABOUeABAPKYgg72ArXAW9XU1CxcuPD555/v1KnTK6+80qVLF9GJAACQQYEHAPyP/RR0X375pclkSkhIsDb27t27X3nllaIDQpjALvBWFy5ceP3113NycgYNGjR9+vQ2bdqITgQAwG9Q4AEg2B05cmTTpk3WC9p37tzZqlUr63ezMwUd7AVDgbc6ffr0jBkz3nzzzbS0tGnTpjVv3lx0IgAAfkWBB4CgU1NT88UXX8hOQRcfH9+yZUvRAaFHwVPgrY4dO/biiy/m5eU9/PDDTz/9dOPGjUUnAgCAAg8AweHMmTMlJSXWxr5z584GDRowBR3cEmwF3qqsrCw7O3vDhg2TJk3KyMho0KCB6EQAgKBGgQeAwMQUdNBWcBZ4q88++ywrK+vw4cPPPPMMXxoPABCIAg8AgcM2BV1paemXX3557ty5Xr16WS9oZwo6eCmYC7zV+vXrJ02aVFNTk52dnZKSIjoOACAYUeABwNgcpqC7/vrr+/TpY72gvX379mFhYaIDIkBQ4E0mU319/QcffJCVlXXNNdfk5ub27dtXdCIAQHChwAOAwThMQXf69Olu3boxBR18jQJvU11dvWjRomeffbZz584zZ868+eabRScCAAQLCjwAGIDCFHRdunShUMEPKPAOzp8//8Ybb7z88su33357Tk4O80oAAPyAAg8AemQ/BV1pael3333Xrl076zA7U9BBCAq8rPLy8pkzZ1q/NP6FF15o1qyZ6EQAgEBGgQcAvbh8+XJxcTFT0EGfKPAKjhw5Mn36dOuXxk+ZMoXfVgCAj1DgAUCko0ePbty4kSnooH8UeJd27979wgsvWL80fsKECZGRkaITAQACDQUeAPyqvr5+x44d1u9mZwo6GAgFXqWSkpKsrKxjx45NmTLlr3/9a0hIiOhEAIDAQYEHAJ9zmIIuMjKyZ8+e1tLOFHQwCgq8W9avXz9x4kSLxfLcc8/xpfEAAK1Q4AFAlU8++aRRo0Y9evRQszBT0CHwUODdVVtbu2DBgmnTpt1www05OTl9+vQRnQgAYHgUeABw4dSpU4888sjy5cv79u27ceNGZ4s5TEF39uzZ3r17MwUdAgYF3jMXL1587bXXcnNz4+PjZ82aFRcXJzoRAMDAKPAA4FRdXd2MGTOys7MtFkt1dXVUVNS5c+fsr2g9derUpk2brBe079y587rrrktISGAKOgQkCrw3KioqcnNzrd829/zzzzPbBQDAM3os8CtXrty6davoFACCUb9+/ZKSkqz//9VXX6Wnpx85cuTixYvWWyIiIr766qvq6mqHKeji4+OtpZ035QhgFHjvHT58+Nlnny0qKnryySefeuqpRo0aiU4EADAYPRb4Xr16tWjRom3btqKDAAguZWVlly5dWrdu3fnz5//2t7+988479fX1dXV1tgWio6NDQkLq6uq6devWu3fvnj179uzZs2nTpgIzA35DgdfKzp07MzMzd+7cmZ2dPXbsWE7VAQCop9MCn5mZOXToUNFBAASXJUuWLFy4cOLEiWPGjKmsrLx06ZLDAmazOSkpaeXKlbzhRhCiwGvriy++mDx58pEjR6ZOncq3zQEAVOLVAgB+VVNTs3v37jvvvPOnn36StneTyWSxWHbv3k17B+C9Hj16bN68+fXXX585c2aPHj02bNggOhEAwAAo8ADwq6qqqqqqqpYtW4aHh4eEhERFRV155ZVRUVFms9m2zA8//HDmzBmBIQEEkuTk5G+//fbBBx9MS0sbNGjQN998IzoRAEDXGEcCgF81atQoPj5+3bp1JpPp1KlTx44dO3bs2NGjR7///vv9+/cfPnz4+PHjv/zyy8mTJ5s0aSI6LIAAER4ePm7cuJEjR77xxht9+/a96667cnNzW7RoIToXAECPKPAAIOOaa6655ppr4uPjRQcBEBQaNWqUmZl53333vfDCC7GxsQ8//PCUKVOuvPJK0bkAAPrCKfQAAAC6cO21186bN+/zzz8/dOhQ69atc3Nzq6urRYcCAOgIBd7Y7C/N9c/m/LxFd/khntmOr7cFAAhCHTp0yM/Pz8vLy8/Pj4uLW7ZsmQ6/MwgAIAQFXr8ciqIe6qKzNxD+iaqHI2AymSz/5eV6/HbQHD5u0MlhBAAoGzhw4FdfffXiiy9mZWX17Nlzy5YtohMBAMSjwOuU2Wy22HFWuvTwkbzKqP6hhwMiJT0m/jlo0q3Yb4gmDwA6ZzabU1JS9uzZM2bMmHvuuSc5OXn//v2iQwEARKLA65G1d9nfos9eajJUVFGkh8g/B012K/a3CP+0BQCgRkRExLhx4/bt29exY8f4+Pjx48efPHlSdCgAgBgUeMOwr15qLsM2O6GwmPJKPIuqfiv2i7lcQDqYrPKAKGxF/apUsq5EZTnXtsMrbFfa4b3fUwCAr8XExOTk5Hz77bcmk6ldu3ZZWVnnz58XHQoA4G8UeJ1S7lQqL8O2/JZJ0hLNiidyS3/qrH673Bfl08WtqewXc1jGPr/DHqk/IC63oiaqSrbq7iySfjqz8oMLANCV66+/ft68eZ9++umXX34ZGxs7f/78uro60aEAAP5Dgdcj+07lcbOS7erKt9hXVtmfSuuoy6jKW3EW2JvyrExhK+qjKlOu7iaNHl9tefmBBQDAn+Lj4z/55JNFixa9+eab1mnqRScCAPgJBV6/NBkKtlJ/IrdnNIxqaO6eM6+3g8ZQPAAYSGJi4vbt26dNmzZ58mTr/4tOBADwOQq8MXh5OrfCidwOvMj4K2lUX2zFR7yM6nEb10mHd3nuAABAV0JCQlJSUsrKygYNGjRw4MDU1NRDhw6JDgUA8CEKfIBTHhC2yNE8g3+2oglNohpxHNutcwcABJXKyspDhw4dOnTo8OHDJpPp8OHD1n9WVlaKjoZfRUVFZWZmHjhw4MYbb7z55pvHjx//888/iw4FAPAJCrweadX9/FDJjFVT/cb+KnfpT1UeNC9nQHB2R9nzI/T8qQoAsZKTk9u3b3/TTTd17do1PDy8a9euN910U/v27ZOTk0VHw280bdo0Jydn+/btFRUVsbGxubm5ly9fFh0KAKAxCrxOSVuWu/1K9i72q5XteLZbnJ0J725U5a14Q/NRbs2jKpxRr/7x9bhXO9sd+xVS3QG41L9//7CwsKqqqqqqqpqaGuv/hIWF9e/fX3Q0yGjbtm1+fv7q1as/+uijdu3azZ8/v76+XnQoAIBmKPA6ZfntLOUOpct+bFbhgm2XV3Q7bEW2e9v/yPLfb2JTGVXNVmwrtF+t9BblPGoOiJqtqImqZlvS2MrHxEcVWnl3fLddAIFk5MiRtbW1DjfW1taOHDlSSB6o0b17902bNi1YsOC1117r3r37p59+KjoRAEAbFHg9ski+89zhp86oWUy6LZU/tb9FZVR3t6Jwi7M8HhwQ5a24dbhc7rj9UXL4p/J9rZ1febVqKB8QL1cOIBi0b9++devWDje2adOmffv2QvJAvcTExB07dowbN27UqFGDBg3auXOn6EQAAG9R4AEAgJKxY8dGRUXZ/hkVFfXXv/5VYB6oFxYWNm7cuAMHDiQmJt52222pqalHjhwRHQoA4DkKPKBTjJAD0IlRo0ZVVVXZ/llVVZWWliYwD9wVHR2dmZlZVlYWExMTFxeXlZXFlwgAgEFR4AE9or0D0I+WLVv+8Y9/tP0zPj6+ZcuWAvPAMy1btpw3b962bdsOHTrUunXr3Nxc+89lAACGQIEHAAAujB07Njo62mQyRUdHjx07VnQceC42NjY/P3/VqlUrV67s3LnzsmXL+MgYAAyEAg8AAFxITU21jtZWVVWlpKSIjgNv9ezZs7i4+MUXX3z66advvfXWzZs3i04EAFCFAg8AAFyIiYnp06ePyWRKSEiIiYkRHQcaMJvNKSkpe/bsGTt2bEpKyqBBg3bv3i06FADAhTDRAQAAEOby5cufffZZXV2d6CAG0LNnz40bN/bs2XP9+vWisxhAaGhoz549GzRoIDqIC+Hh4ePGjUtJScnNze3Vq1daWtq0adOaN28uOhcAQB4FHgAQvD744INHH320TZs2ooMYQF1dXePGjVevXr1mzRrRWQzgwIEDr7/++n333Sc6iCoxMTE5OTmPPfbY3//+9/bt2z/88MNTp0694oorROcCADiiwGvDbDbrbQ4YHUYC/IlfAahRVVWVkJCwatUq0UEQaO666y7DzfF+3XXXzZs374knnsjMzIyNjX3++efHjBkTFsZ7RQDQEa6Bhxhms1mTldhouNog54uHhscFAIyiY8eORUVF//rXv+bOnRsXF7ds2TLRiQAA/0OB14beBvqCYezRuo829jXefhmHhg8/kD40ssv4+qFxtmkAgEuJiYmlpaUvvPDC3/72t969e2/dulV0IgCAyUSBh0FJP6GwdkXpMjb+DRi8ZB8a2WV4aABAz0JCQlJSUr755puBAwcOHjx47NixP/74o+hQABDsjFrgHc6adjaOpzzKJ3sCtu2MX2fDuerX76OoLs9JVhh+d7ke6QKy++JNVOlKlA+gWzvoizbo1sH33VYM8dA4I+pxYRAeALx0xRVXvPDCC3v27AkJCenQocPzzz9//vx50aEAIHgZtcDb+oDZbihP2kYUzuN19lPrmmX7hvRGNUOImkf1uJO4XI/LBaz7on5HZKPajpjDkh7skR9odfC93IqxHho/dGb/PC4AAKuWLVu+/fbbX3311Z49e/7whz/k5uYaboo+AAgMRi3wVubfjsTa/79Z7jxe21t85Z/qKqoszzqV9F7KMZwlcdgRzaNqxfvH1OVB00SAPTS2Oq0wgO+LXzfdfgYEAAGjXbt2+fn5RUVFK1eutM5vx99eAPAzYxd4bV82fPoi5M3KHeqQtflolVbzY+i7qO6y9l77T220WrN/9sjQD43y2Lj3D42unmkAEFRuvfXW4uLil156KTMzs1evXiUlJaITAUAQMXaBV2aWEJ3IKZdRDXS2sE6iOoxayw5iBxtRD43DtrR6aHTyTAOAIGQ2m1NSUr799tthw4b96U9/Sk1NPXTokOhQABAUArnAW+SIDiXP3agGqivCowoPoFvCj4y2AYTvDgAEm4YNG2ZmZh44cKBFixZxcXEZGRm//PKL6FAAEOACucAHDJ/WEm1X7p8GpVDVnF1xrW0Ah6346BQPIz407m7I44eGrg4AOtG0adM5c+Zs3779xIkTbdq0yc3Nra6uFh0KAAJWwBZ4Z1feOvupmgLmo86gHNXZP91tPnB4cUEAACAASURBVAqXIqtcQCXPorpbgNWk9f7qd7eOicddNMAeGjUb8v6hUbMVwP/UP6UVfrMM9PmUHqIa4kK5YNC+ffv8/Pz33nvvvffes85vJzoRAAQmoxZ4s+TbqqXLSKe5sn9/7/BT6Vnrzu5u3z3st+4sjPdRZdMqHBxnA9TubkW6gG1fFG5RGdXl8XfJ5eNr+u9ht10jLXtYvNmKVgL7oZHui8kHD41sSB89XggqZie8XK3+n5ne76N/aHKJnPSRNcru683AgQO/+uqrF198cfLkyT179ty6davoRAAQaIxa4FVeMa68jAd3t19YmkF2bd5Htd+0l29TXCZRecSc3eJWVO/3yK20Hm9IeStmjeY/D5iHRs2GvH9o3NodwBu2J5jD76BswdPkqWig57OBotozy52/Y//IShfwb0BjCwkJSUlJKSsrGzZs2JAhQ1JTUw8fPiw6FAAEDqMWeChz9uYSCB4MvwOQMksutnL4QyH9TJCXVA9ERUVlZmbu2bMnJiamY8eOGRkZlZWVokMBQCCgwAPeoiUCQU7NqfUul1G/EoflvdyWWe4CHLPk4i/pAi4vJXB2d2db8WAlbrGuQbm928h2eC8DBKEWLVrMmzevtLT00KFDrVu3njNnTm1trehQAGBsFPj/kb6JMTRapX9wnHWLhwa+Y5ZMuqF8KYfZ1UnaalZisntW26/Q7OqEcOUw0mWcXTXgVlQ1W1HeETUrUclW3b35s6Dw2EFZhw4dVq1alZeXt3Dhwk6dOjG/HQB4gwL/P2rekQAAgpPH48DSYV4vX2ukHx8ob8th8Fy6ac1f+JxtRfZjC4UFNAnmfXW3583nCEEuMTFx+/btU6ZMycjIGDhw4Pbt20UnAgBDosADAOCaJkPBWiUxxDqFk54zrxWG4j0TEhKSnp6+f//+22+/vX///qmpqd9//73oUABgMBR4AADcptthWLOE6ERe8WZffPdRi7aj+sEmOjo6MzOzrKwsJiYmLi4uKyuL+e0AQD0KPAAAgcMiR3QoD0mvgfdgJdqOlvtuVD/YXHvttfPmzfv888+/+eYb5rcDAPUo8AAABDsdDtRr2JOdzT+nMD4vO6MeA++a69ix40cffZSXl/fPf/6T+e0AQA0KPP7H2RiFDt/YBRgPjjAPCiCW+nopbYm+O7Pd2VzuLhdwuS9uZfZ4Ky4zeHN32TPqVUaluvuUdX67iRMnPv744wMHDtyxY4foRACgXxR4wdS8JfLbRYy+e2sSYG3TKLsTAJe/AsLZfo8cLsa2/cF0uEJb9oJt2/CvwyiubRk1K7Et7+ynstuSdlGXC7jMrCaqy63Y7u7sFmdrcLiLmjDSYO5Gpbr7WlhY2Lhx4w4cOJCQkNCnT5/U1NQjR46IDgUAekSBF8ms4hN9Ncv4Gm9cfMqzt4ZqZmbyfgInb+4LBAbZS8otv/3yM5fLOCxmf4vHK1F4aXC5jJqVyGZWH9XlVhTWrLAGj8M4bNrdqAprg4YaNWqUnZ29b9++mJiYTp06ZWVlnT17VnQoANAXCjwApyx6nWcbABCorrvuunnz5m3YsOHzzz9nfjsAcECBNzCHU/5M7o+XKp9tqOZcRJcxZM9sdLk5s+SsUYeVeJDErZ1S3lmXu+NyZ+2XlB3bUbMv/mnXFr7uGADgd127dt24cePSpUvffvvtuLg45rcDACsKvFGZJV+u427FcliDtKSpORHRZQyH8x6drVN5PZb/XveosLNqDoh0l1UdKTd3R/OHxrOoGnL2DAEAwKcSExN37Njx5JNPPvbYY4mJiV9//bXoRAAgGAXekGSHbZWbtss1uOzqKnm2EjX3svz2ukfzb8f5XR4Q2V3WvJE6S+LlhjR5aLykh48SAADBJjw8fNy4cfv27evatWvv3r2Z3w5AkKPABxT/1zyLZPJeITGc0U8St/jnqJqdUJlN2zAAACi46qqrcnJy9u7d26BBg44dOzK/HYCgRYEXw1qBlCuZmmX0QKuTvd2qkZpsQs8tVMNT6J1VbosTymsz6+BrEQAAwen6669fvHjxhg0btm7dap3frq6uTnQoAPArCrwYalqZQc9Y9iyz9KpvH2Vzt6/qhJefjGiyp0b5RAkAENi6deu2efPmBQsWvPbaa3FxcUVFRaITAYD/UOADiuy0bT4datZkzb6rhYb7+MNKb7Ft1Z32DgDQieTk5D179kyYMGHMmDGDBg3auXOn6EQA4A8UeEOSHY91qwZL1+Bxz5euR81p2MrbcjeJmgPibBm3NiTLfne8f2hkgwkc+qa6AwD0yTq/3d69e+Pj43v27Jmenn7ixAnRoQDAtyjwRiWd58zdiuWwBltJM0u+51z6T+X1qN+W8r7YtmXLYLuL9BY1B8T7g+bN7iisSs0mpMt4nF89P2wCAABvNGnSJCcnZ+fOnZcvX27btm1WVta5c+dEhwIAX6HAG5iaa7lV/tS2gO3/ZS8Xl65KurCatGr2RZrKoSTLhlF/QJTTuuTu7ri7cpeb8A+BmwYAQL22bdvm5+d/8sknxcXFsbGx8+fPZ347AAGJAg8IZvFi2j9f5AEAwKB69OixZcuW//u//8vJyencufOHH34oOhEAaCxMdICgZmtuygPXLpcBZPHMAdSoqampqKgQnQKBpqamRnSEIGU2m1NSUoYMGTJjxowRI0bccccdubm5bdq0EZ0LALRBgRdMTbmigAU8j0+z13y1QLBp2rTpmjVrmjRpIjoIAk1ISMhTTz0lOkXwio6Ozs7OHjdu3DPPPBMXF/foo49OnTo1JiZGdC4A8Ban0AMmswqiMwLwiaFDh1qCWGVlZZs2bWbMmOGHbW3dujUmJmbWrFl+2JYe1NXVJSYmin6CB7uWLVsuWLDg66+/Pnr0aKtWrbKzsy9fviw6FAB4hQIPKM3YZyM6IwBozGKxjBo16uabb540aZIfNtezZ8+tW7fOnj37iSeeqK+v98MWAav27dvn5+cXFhYWFha2a9du8eLFvKwDMC4KPAAAwWj27Nn79+9fuHCh37YYGxtbXFy8du3av/zlL1wiDj8bOHDg9u3bX3zxxczMzFtvvbWkpER0IgDwBAUeAICgU1JSkp2dnZ+ff8UVV/hzu61atdq6dev+/fvvueeeS5cu+XPTQEhISHp6+oEDBwYPHnz77benpqYePnxYdCgAcA8F/n+41NmBwgFxeaDUXEPOdeYAIER5eXlaWpr1e7b8v/UmTZqsX7/+8uXLgwcPrqys9H8ABDnr/Hb79u2LiYmJi4vLyso6e/as6FAAoFaAF3i3OqHvLohy6KhGaaoeHxDrV5QrX0OuZpmgYpRnhUmjqNIPbjQ/AnwqBMiyWCx/+ctf+vbt+8gjj4jK0KhRo1WrVl199dUDBgw4deqUqBgIZtddd928efM2btz42WeftW7des6cOXV1daJDAYBrAV7g9cChqeqqUXgcJsjLNtzl8EyT/lLYL6DV74gOf+MAPZgxY8ahQ4feeustsTEiIyPfe++9Ll269OzZ8+DBg2LDIGh17dp106ZNCxYseO211+Li4j766CPRiQDABQq8b1mLiv0t+qm+0myALzg802R/KexvoXUDvrNly5aXXnopPz+/UaNGorOYQkND33777XvuuSchIWHXrl2i4yB4JScn79mzZ/z48aNGjRo0aNDu3btFJwIAp4xa4KXXTkuH+Gy3O7vKWs3V12ouz3b3Em7Z2uwsp8OOONyosBKXgWVPa1e+u8oFlJdUs4xb2zI5fwjciiG7FZPqJ5vLw668fmcbkl2z7GJqwvguqsLyyu3dRtrhXYb0Zl+AIPTzzz+PHDlyxowZcXFxorP8ymw2v/LKKxkZGf369fvss89Ex0HwCg8Pz8jIOHjwYHx8/K233jp+/Hgu7gCgT4Ys8GbJ5dPSd/C2MT1nV1mbFU/i1TatmmWc7ZE1s20BWyOS7rV0j2Q3ZFtMOYPsAZEeRtkFTL897B4so2ZfbPeyX9h+SeWVOBxYhSPm7KFRH1WZ7AGxv8Uk+dDH2U+Vw/g0qgOFZ5pb26KfA1qpq6tLS0vr37//uHHjRGdxlJmZ+eqrrw4ePHjt2rWisyCoNWnSJCcnp7S0tKKiIjY2Njc3t6qqSnQoAPgNQxZ4KXdLgnQY0JumocC+hChUEZebtvx2cFK6gOweOetvKu/uiwOihpp9cbawQ5V1uRKH+8oeMYW7uBVVQ7LBlMP4M6qX1d2ex581AHCQm5t7/PjxuXPnig4ib/To0YsWLUpJSVm2bJnoLAh27du3z8/Pf//99/Py8jp16rRs2TJR74gAQMqQBd6hElvf3Pvob6vCGKP6Zbwc9vSe9EzmgCFkp/y8UZVPGz08vj56pjkbilfz6wnAZDJ98sknOTk5+fn50dHRorM4NWzYsIKCgnHjxr399tuiswCmAQMGlJaWPvvssxkZGb169eISDwA6YcgCb5KcwWugATpnaaUfSbjLLGG/UWMdJYV98fNKdLIVTfghqo+ead4M6XMePnDixIlRo0b93//9X6dOnURncWHAgAFr166dOnVqbm6u6CyAKSQkJD09ff/+/cOGDUtKSkpNTT1y5IjoUACCnVELvANjtVMps+RCaw9WYpHjsIBRmozLffHbSvSzFbPzk+HVr8QPUU2aPtOUh/TVfBLhTfkHAkBdXd2oUaOSkpLGjBkjOosq3bp127Rp0+uvv56RkcFvLvQgOjo6MzOzrKwsJiamU6dOWVlZ586dEx0KQPAyZIH3ZwVV2RCcLaMmqsd9zAPWJmOUGq9b+jx6ukrl7Jmm8Fmbw+226u7yt4O3+ICCl1566eTJk2+88YboIG7o0KFDcXHxxx9/PHr06NraWtFxAJPJZLr22mvnzZu3cePGzz77LDY2dv78+XV1daJDAQhGhizwJrn3+mrexNvqhLRF+PQUa4d/uozqQRLZXuRsPbZypXB3gSXfrX0RshLbI6jJVmQ5q74Kzx/ZB1FIVPtI0u26PKomdcPmtt9lD3MDQWDdunWzZs0qKCjQ86Xvsn7/+99v3rx5165d99xzz+XLl0XHAX4VHx+/adOmt95665VXXunevfvGjRtFJwIQdIxa4C2/ncdOudLYL+bQZ6Q/0ry1uozqsIBtGbPdV47bp3L2/87WoxxMIafDAbH/qfSf9ss4+6n6ZdTsi5crcXZgzU5qs7Mk7h52ZxSeq96sRA9RnXV4hYeGWg547/jx4/fdd9/cuXPbtWsnOosnmjVrtmHDhoqKisGDB589e1Z0HOB/kpOT9+zZk56ePnz48EGDBn377beiEwEIIoYs8BZX3yLusLCzxaQ/ki7m1iY8jmr5LfskCgkV0qqsfwp3d7Y5Wc4CyMZQs4yaffFyJQrhvUwiXUAlNStxuX79RHVYXn0S9cG82QUgsNXV1Y0cOfJPf/pTWlqa6Cyea9y48bp165o0aTJgwICff/5ZdBzgf8LDwzMyMg4ePBgfH9+jR4/x48fzFAXgH4Ys8ABAewcUTJs2rbKy0liXvsuKjIzMz8+/+eab+/bte+zYMdFxgN9o0qRJTk7O9u3bKyoqYmNjc3Nzq6qqRIcCEOAo8IAxcGK5u7y5TAAwtDVr1rz22mv5+fkNGjQQnUUDoaGh77zzzp133tmnT599+/aJjgM4ateuXX5+/rJly/Ly8uLi4pYtWyY6EYBARoEHdM3+Cn/pdf62ZRR+GrS8vEwAMKgff/wxPT39rbfeatu2regsmjGbzTNnznzkkUd69er1+eefi44DyBgwYEBpaekzzzyTkZExYMCAHTt2iE4EIDBR4AFfMavgciVqrlr3/pp2TaICEK62tnbkyJHDhg0bMWKE6Czay8zMfPHFF++4445169aJzgLICAkJSU9PP3DgwB133NGvX7/09PQTJ06IDgUg0FDgAV+xqCA6468MFBWAgueee+78+fNz5swRHcRXHn744bfeeuvuu+9+//33RWcB5EVFRWVmZpaVlTVs2LB9+/ZZWVnnz58XHQpA4KDAAwAQCFauXPnmm2++9957gXHpuzNpaWmFhYUPPvjgO++8IzoL4NS11147b968DRs2fP7557GxsfPnz6+vrxcdCkAgoMADAGB4R44ceeCBB95+++02bdqIzuJzAwcOXLNmzdNPPz1jxgzRWQAl8fHxGzdunDt37owZM7p3775582bRiQAYHgUeAABjq66uHjFixL333puSkiI6i590795948aNc+bMycrK4hof6FxycnJZWdm4cePuueee5OTkgwcPik4EwMAo8AAAGNszzzxTW1s7a9Ys0UH8qmPHjsXFxcuXL3/ggQdqa2tFxwGUhIeHjxs3bt++fR07drzlllsyMjJ++eUX0aEAGJIevyS5b9++x48fv+qqq0QHgV5cuHAhKiqKidDha2fOnLnpppuKiopEBwHcUFhY+MADD3z11VetW7cWnUWAn376afDgwX/4wx+WLl0a2Bf/I2B89913zzzzzKeffjp58uQnn3wyIiJCdCIARqLHAr9v375jx46JTgG9OHXq1OjRo5ctWxYdHS06CwJfp06dmjdvLjoFoNbhw4e7du26aNGi5ORk0VmE+eWXX5KTk8PDw1esWHHFFVeIjgOosmHDhqeeeurixYt///vfg+fiFwDe02OBB+y99tprH3300erVq0UHAQB9qa6uTkhIuPXWWwP4e+NUunjx4p///Ofy8vKPPvro6quvFh0HUKW+vv6DDz6YNGlS27ZtX3311Ztvvll0IgAGwDXw0LvCwsJhw4aJTgEAupOVlRUaGjpz5kzRQcSLiopauXJlx44d+/bt+8MPP4iOA6gSEhKSkpKyZ8+eQYMG3Xbbbenp6T/99JPoUAD0jgIPXSsvLy8uLqbAA4CD5cuXL168OC8vLzw8XHQWXQgLC1uwYEFSUlKfPn2+++470XEAtaKiojIzM3fs2HH58uWOHTvOnj27urpadCgA+kWBh659+OGHXbt2bdasmeggAKAjhw4d+utf/7po0aJWrVqJzqIjZrN51qxZDz/8cN++fXfs2CE6DuCGG264IT8/f8WKFUuXLu3UqdOKFStEJwKgUxR46FpBQcHw4cNFpwAAHamqqhoxYsQDDzzwpz/9SXQWPcrMzHz22Wf79eu3fv160VkA9/Tp02fbtm2vvvrqxIkTu3fvXlxcLDoRAN1hEjvo14ULF373u9/t2rUrOL8bCQBkPfHEE9u3b9+4cWNYWJjoLPq1ZMmS8ePH/+tf/7r77rtFZwHcVl1dPXfu3Ozs7EGDBuXm5t5www2iEwHQC0bgoV9r1qxp06YN7R0AbN5///2lS5cuXbqU9q5s5MiReXl5o0ePXrBggegsgNsiIiIyMjIOHDjQokWLm2++OSsr6+zZs6JDAdAFCjz0q7CwkPPnAcBm3759Y8eO/de//nX99deLzmIAd95554cffvjUU0+9+uqrorMAnmjatOmcOXO++OKLXbt2xcbGzp8/v66uTnQoAIJxCj10qrq6ulmzZp9++mmXLl1EZwEA8S5dunTrrbcmJSXl5uaKzmIku3fvvuOOO+6///6cnBzRWQDPrV+/fsKECREREbNmzerXr5/oOACEYQQeOrV58+aYmBjaOwBYPfXUU40bN37ppZdEBzGYTp06FRcXf/DBB4888kh9fb3oOICHEhMTd+zY8dBDD6Wmpg4aNKisrEx0IgBiUOChUwUFBUOHDhWdAgB04d13333//feXLFnCpe8euOGGG7Zs2VJSUjJq1KiamhrRcQAPhYeHjxs3bt++ffHx8d27dx8/fnx5ebnoUAD8jQIPPbJYLFwADwBWe/fufeyxx5YuXXrdddeJzmJUzZs337hx49GjRwcPHnzu3DnRcQDPxcTE5OTkbN++vaKion379rm5udXV1aJDAfAfCjz0aNu2bbW1tb179xYdBAAEu3jxYmpq6qOPPjpw4EDRWYwtJiZm7dq14eHhiYmJp0+fFh0H8Eq7du3y8/Pz8/OXLFnSuXPnZcuWiU4EwE8o8NCjgoKC5OTk0NBQ0UEAQLAJEyZcc801f//730UHCQTR0dErVqy44YYb+vbt++OPP4qOA3hr4MCBO3bsmDJlyuOPP56YmPjNN9+ITgTA5yjw0KPly5cPGzZMdAoAEGzx4sVFRUX/+c9/QkJ4vdZGRETEf/7zn4SEhD59+uzfv190HMBbISEh6enpBw4c6NOnT8+ePdPT00+ePCk6FAAf4g0BdGfPnj0//fTToEGDRAcBAJHKysoef/zx//znP82aNROdJaCEhoa+9dZbDz30UEJCwtdffy06DqCBRo0aZWdn792712QytWnTJjs7+/Lly6JDAfAJCjx0p6CgICkpKTIyUnQQABDGeun7hAkT+vfvLzpLYMrMzJw6derAgQOLi4tFZwG0cf311y9evHj9+vVr165t167d4sWLLRaL6FAANGbmFxt6061bt4kTJ6alpYkOAgDCjBkz5ocffvj44485ed6n3n333ccee2zJkiVDhgwRnQXQjMVief/99ydNmtSiRYtZs2b16tVLdCIAmuFtAfTl6NGju3bt4o0UgGC2aNGiNWvWvPvuu7R3X7vvvvv+/e9/jxgxYtGiRaKzAJoxm80pKSl79uwZPnz44MGDU1NTjxw5IjoUAG3wzgD6smLFiv79+zdu3Fh0EAAQY+fOnY8//viSJUuuueYa0VmCQnJyclFR0ZNPPjl79mzRWQAtRUVFZWZmlpWVxcTEdOrUKSsr69y5c6JDAfAWBR76UlBQMHz4cNEpAECMc+fOpaam/u1vf7vttttEZwkit9122yeffJKTk5OVlSU6C6Cxa6+9dt68eRs2bCgpKYmNjZ0/f35dXZ3oUAA8xzXw0JHy8vJrr7326NGjTLkMIDilpaVVVFR89NFHnDzvf4cOHbr99tuTkpL+8Y9/cPwRkFatWpWRkdGkSZNZs2b17dtXdBwAnuD1CTry4Ycfdu3alfYOIDj985//3LJly7///W/aoxA33njjli1bNm/efP/999fU1IiOA2gvOTl57969999/f3JycnJy8sGDB0UnAuA23iJARzh/HkDQ2rFjx4QJE5YsWfK73/1OdJbg1aJFi02bNh0+fHj48OEXL14UHQfQXkREREZGxsGDB2+88cZOnTplZGRUVlaKDgXADRR46MWFCxfWrl1LgQcQhM6ePTtixIgpU6ZwUqtwMTEx69atq6mpGTBgwOnTp0XHAXzi6quvnjNnTmlp6Xfffde6des5c+bU1taKDgVAFQo89GLNmjVt2rRp3bq16CAA4G8PPvhghw4dmEFNJ6Kjo1etWtWqVavbbrvt+PHjouMAvnLTTTetXr164cKFr7/+elxc3Icffig6EQDXKPDQC86fBxCc5s2b98UXXyxcuNBsNovOgl9FREQsXbq0V69effr0OXDggOg4gA8lJyeXlZU99NBD991336BBg3bt2iU6EQAlFHjoQnV1dVFREQUeQLDZvn375MmT33vvvSZNmojOgt8IDQ2dN29eampqQkLCzp07RccBfCg8PNx6YfxNN93UvXv38ePHnzp1SnQoAPIo8NCFzZs3x8TE3HLLLaKDAID/VFZWjhgx4tlnn+3Ro4foLJBhNputXw4/YMCAkpIS0XEA32rSpMmcOXO+/vrr48ePt2/fPjc3t6qqymGZkpIS5q4HxOJ74KELjz76aERExOzZs0UHAQD/SU1NrampWb58OSfP69zixYufeOKJvLy8pKQk0VkAf1i/fv3EiRMvXbo0ffr0lJQU641nzpxp1apVgwYNdu7cee2114pNCAQtRuAhnsViKSws5Px5AEHljTfe+OqrrxYsWEB717/09PTFixePGDHivffeE50F8IfExETrBT6PPfZY//79d+zYYTKZJk+eXFtbW1lZ2adPn4qKCtEZgSBFgYd427Ztq62t7d27t+ggAOAnpaWlTz/9dF5eXkxMjOgsUOWuu+5asWLFQw899NZbb4nOAvhDWFjYuHHjdu/e3aFDh169eqWnp//73/+uqqqqra09fvz4HXfcIT3BHoAfcAo9xMvKyiovL3/nnXdEBwEAfzhz5swf//jHjIyMJ598UnQWuKe0tHTw4MFjxozJyckRnQXwn2+//Xbo0KFHjhyxfV18gwYNkpKSuAII8D9G4CHe8uXLOX8eQJCwWCyjR4+Oj4+fMGGC6CxwW3x8/ObNm5csWfL444/X19eLjgP4ycGDB3/88UdbezeZTJcvX16zZk1WVpbAVEBwYgQegpWVld16660///xzZGSk6CwA4HNz5sz5xz/+UVpaetVVV4nOAg8dPXr09ttv79at24IFC8LDw0XHAXyrqqqqdevWx48fl7aGyMjIV1999dFHHxUSDAhOjMBDsMLCwqSkJNo7gGCwdevWqVOnvvfee7R3Q2vVqtXWrVsPHDhw9913X7p0SXQcwLe2b9/+448/hoWFSX9UVVU1ceLETz/91P+pgKDFCDwE69at28SJE9PS0kQHAQDfOn36dJcuXSZPnvz444+LzgINnD9//u67766qqlq5cmXjxo1FxwF8pb6+vrCw8JtvviktLd2+ffuJEycaNGgQHh5+4cKFuro6k8nUsGHDbdu2derU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" alt="Oops!" style="width:100%;"></p>
<h5 id="namespace-cursor-synopsis-cursor.synopsis">24.8.9.1.1  Namespace cursor synopsis [cursor.synopsis]</h5>
<pre><code>namespace std {
namespace experimental {
namespace ranges {
inline namespace v1 {
  namespace cursor {
    
    // Cursor traits 

    // single_pass trait
    template &lt;class&gt; constexpr bool single_pass = false;
    template &lt;class C&gt;
      requires requires {
        typename C::single_pass;
        requires bool(C::single_pass::value);
      }
    constexpr bool single_pass = true;

    // contiguous trait 
    template &lt;class&gt; constexpr bool contiguous = false;
    template &lt;class C&gt;
      requires requires {
        typename C::contiguous;
        requires bool(C::contiguous::value);
      }
    constexpr bool contiguous = true;

    // category trait
    template &lt;class&gt;
      struct category {};
    template &lt;Input C&gt;
      struct category&lt;C&gt; { using type = input_iterator_tag; };
    template &lt;Forward C&gt;
      struct category&lt;C&gt; { using type = forward_iterator_tag; };
    template &lt;Bidirectional C&gt;
      struct category&lt;C&gt; { using type = bidirectional_iterator_tag; };
    template &lt;RandomAccess C&gt;
      struct category&lt;C&gt; { using type = random_access_iterator_tag; };
    template &lt;Contiguous C&gt;
      struct category&lt;C&gt; { using type = ext::contiguous_iterator_tag; };
    template &lt;class C&gt;
      using category_t = typename category&lt;C&gt;::type;

    // types
    template &lt;class C&gt;
      using mixin_t = <em>see below</em>;
    template &lt;class C&gt;
      requires <em>see below</em>
      using value_type_t = <em>see below</em>;
    template &lt;class C&gt;
      using difference_type_t = <em>see below</em>;
    template &lt;class C&gt;
      requires
        requires(const C&amp; c) {{c.read()} -&gt; auto&amp;&amp;;}
      using reference_t = <em>see below</em>;
      
    // concepts
    template &lt;class C&gt;
      concept bool Cursor();
    template &lt;class C&gt;
      concept bool Readable();
    template &lt;class C&gt;
      concept bool Arrow();
    template &lt;class C, class T&gt;
      concept bool Writable();
    template &lt;class S, class C&gt;
      concept bool Sentinel();
    template &lt;class S, class C&gt;
      concept bool SizedSentinel();
    template &lt;class C&gt;
      concept bool Next();
    template &lt;class C&gt;
      concept bool Prev();
    template &lt;class C&gt;
      concept bool Advance();
    template &lt;class C&gt;
      concept bool IndirectMove();
    template &lt;class C, class O&gt;
      concept bool IndirectSwap();    
    template &lt;class C&gt;
      concept bool Input();
    template &lt;class C&gt;
      concept bool Forward();
    template &lt;class C&gt;
      concept bool Bidirectional();
    template &lt;class C&gt;
      concept bool RandomAccess();
    template &lt;class C&gt;
      concept bool Contiguous();
}}}}}</code></pre>
<h5 id="cursor-traits-cursor.traits">24.8.9.1.2  Cursor traits [cursor.traits]</h5>
<h6 id="single_pass-cursor.single">24.8.9.1.2.1  <code>single_pass</code> [cursor.single]</h6>
<pre><code>template &lt;class&gt; constexpr bool single_pass = false;
template &lt;class C&gt;
  requires requires {
    typename C::single_pass;
    requires bool(C::single_pass::value);
  }
constexpr bool single_pass = true;</code></pre>
<p><code>using single_pass = stl::true_type;</code> is defined by a cursor to specify to <code>basic_iterator</code> that the cursor does not satisfy the <code>cursor::ForwardIterator</code> concept despited satisfying the <code>cursor::InputIterator</code> and <code>cursor::EqualityComparable</code> concepts.</p>
<h6 id="contiguous-cursor.contig">24.8.9.1.2.2  <code>contiguous</code> [cursor.contig]</h6>
<pre><code>template &lt;class&gt; constexpr bool contiguous = false;
template &lt;class C&gt;
  requires requires {
    typename C::contiguous;
    requires bool(C::contiguous::value);
  }
constexpr bool contiguous = true;</code></pre>
<p><code>using contiguous = stl::true_type;</code> is defined by a cursor to specify to <code>basic_iterator</code> that the cursor satisfies the <code>cursor::Contiguous</code> concept if it also satisfies the <code>cursor::RandomAccess</code> concept.</p>
<h6 id="types-cursor.types">24.8.9.1.2.3  Types [cursor.types]</h6>
<p>These type traits are used in cursor concepts, traits, and in class basic_iterator to access types defined by cursors or deduced from the presence of cursor functions.</p>
<pre><code>template &lt;class C&gt;
  using mixin_t = <em>see below</em>;  // used by concepts, etc</code></pre>
<p>Type <code>mixin_t</code> is defined as <code>C::mixin</code> if type <code>C::mixin</code> is defined. Otherwise it is defined as <code>basic_mixin&lt;C&gt;</code>.</p>
<pre><code>template &lt;class C&gt;
  requires <em>see below</em>
  using value_type_t = <em>see below</em>; // used by concepts, etc.</code></pre>
<p>The <code>requires</code> clause is satisfied if and only if <code>Same&lt;deduced_value_t&lt;C&gt;::type, decay_t&lt;deduced_value_t&lt;C&gt;::type&gt;&gt;()</code> would be satisfied.</p>
<p>Type <code>value_type_t</code> is defined as <code>deduced_value_t&lt;C&gt;::type</code>.</p>
<p><em>Remarks:</em> <code>template &lt;class C&gt; deduced_value_t;</code> is an exposition only type defined as:</p>
<ul>
<li><code>struct value_type&lt;C&gt; {using type = typename C::value_type;};</code> if <code>C</code> has a member <code>value_type</code>,</li>
<li>Otherwise <code>struct value_type&lt;C&gt; {using type = decay_t&lt;reference_t&lt;C&gt;&gt;;};</code> if <code>C</code> does not have a member <code>value_type</code> and satisfies a requirement for <code>reference_t&lt;C&gt;</code>.</li>
<li>Otherwise <code>struct deduced_value_t {};</code>.</li>
</ul>
<pre><code>template &lt;class C&gt;
  using difference_type_t = <em>see below</em>; // used by concepts, etc.</code></pre>
<p>Type <code>difference_type_t</code> is defined as:</p>
<ul>
<li><code>C::difference_type</code> if <code>C</code> has a member <code>difference_type</code>,</li>
<li>Otherwise <code>decltype(declval&lt;const C&amp;&gt;().distance_to(declval&lt;const C&amp;&gt;()))</code> if <code>C</code> has such a <code>distance_to</code> member function,</li>
<li>Otherwise <code>std::ptrdiff_t</code>.</li>
</ul>
<pre><code>template &lt;class C&gt;
  requires
    requires(const C&amp; c) {{c.read()} -&gt; auto&amp;&amp;;}
  using reference_t = <em>see below</em>;  // used by traits, etc.</code></pre>
<p>Type <code>reference_t</code> is defined as <code>decltype(declval&lt;const C&amp;&gt;().read())</code>.</p>
<h5 id="concepts-cursor.concepts">24.8.9.1.3  Concepts [cursor.concepts]</h5>
<pre><code>template &lt;class C&gt;
  concept bool Cursor();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Semiregular&lt;remove_cv_t&lt;C&gt;&gt;()</code><br />
 <code>&amp;&amp; Semiregular&lt;mixin_t&lt;remove_cv_t&lt;C&gt;&gt;&gt;()</code><br />
 <code>&amp;&amp; requires {typename difference_type_t&lt;C&gt;;}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Readable();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;() &amp;&amp; requires(const C&amp; c) {</code><br />
 <code>{c.read()} -&gt; auto&amp;&amp;;</code><br />
 <code>typename reference_t&lt;C&gt;;</code><br />
 <code>typename value_type_t&lt;C&gt;;</code><br />
 <code>}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Arrow();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Readable&lt;C&gt;()</code><br />
 <code>&amp;&amp; requires(const C&amp; c) {{c.arrow()} -&gt; auto&amp;&amp;;}</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class T&gt;
  concept bool Writable();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;()</code><br />
 <code>&amp;&amp; requires(C&amp; c, T&amp;&amp; t) {c.write(ranges::forward&lt;T&gt;(t));}</code>.</p>
</blockquote>
<blockquote>
<p><em>Remarks:</em> Not required to be equality-preserving.</p>
</blockquote>
<pre><code>template &lt;class S, class C&gt;
  concept bool Sentinel();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;() &amp;&amp; Semiregular&lt;S&gt;()</code><br />
 <code>&amp;&amp; requires(const C&amp; c, const S&amp; s) {{c.equal(s)} -&gt; bool;}</code>.</p>
</blockquote>
<pre><code>template &lt;class S, class C&gt;
concept bool SizedSentinel();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Sentinel&lt;S, C&gt;()&amp;&amp; requires(const C&amp; c, const S&amp; s)</code><br />
 <code>{{c.distance_to(s)} -&gt; Same&lt;difference_type_t&lt;C&gt;;}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Next();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;() &amp;&amp; requires(C&amp; c) {c.next();}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Prev();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;() &amp;&amp; requires(C&amp; c) {c.prev();}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Advance();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Cursor&lt;C&gt;()</code><br />
 <code>&amp;&amp; requires(C&amp; c, difference_type_t&lt;C&gt; n) {c.advance(n);}</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
concept bool IndirectMove();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Readable&lt;C&gt;()</code><br />
 <code>&amp;&amp; requires(const C&amp; c) {c.indirect_move()} -&gt; auto&amp;&amp;;};</code>.</p>
</blockquote>
<pre><code>template &lt;class C1, class C2&gt;
concept bool IndirectSwap();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Readable&lt;C1&gt;() &amp;&amp; Readable&lt;C2&gt;()</code><br />
 <code>&amp;&amp; requires(const C1&amp; c1, const C2&amp; c2)</code><br />
 <code>{c1.indirect_swap(c2); c2.indirect_swap(c1);}</code>.</p>
</blockquote>
<blockquote>
<p><em>Axiom:</em> If <code>c1.read() == x</code> and <code>c2.read() == y</code> then after either <code>c1.indirect_swap(c2)</code> or <code>c2.indirect_swap(c1)</code>, <code>c1.read() == y</code> and <code>c2.read() == x</code>. No diagnostic required.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Input();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Readable&lt;C&gt;() &amp;&amp; Next&lt;C&gt;()</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Forward();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Input&lt;C&gt;() &amp;&amp; Sentinel&lt;C, C&gt;() &amp;&amp; !single_pass&lt;C&gt;</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Bidirectional();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Forward&lt;C&gt;() &amp;&amp; Prev&lt;C&gt;()</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool RandomAccess();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>Bidirectional&lt;C&gt;()</code><br />
 <code>&amp;&amp; Advance&lt;C&gt;() &amp;&amp; SizedSentinel&lt;C, C&gt;()</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  concept bool Contiguous();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>RandomAccess&lt;C&gt;() &amp;&amp; contiguous&lt;C&gt;</code><br />
 <code>&amp;&amp; is_reference&lt;reference_t&lt;C&gt;&gt;::value</code>.</p>
</blockquote>
<p><span style="background-color:lightgrey"><em>Add to 24.6, Header <code>&lt;experimental/ranges/iterator&gt;</code> synopsis [iterator.synopsis]:</em></span></p>
<pre><code>  // basic_mixin
  template &lt;Destructible T&gt;
  class basic_mixin;</code></pre>
<p><span style="background-color:lightgrey"><em>Continue to add to Basic Iterators [iterators.basic]:</em></span></p>
<h4 id="class-template-basic_mixin-iterator.mixin">24.8.9.2  Class template <code>basic_mixin</code> [iterator.mixin]</h4>
<p>Class template <code>basic_mixin</code> describes a mixin type.</p>
<p>Class <code>basic_mixin</code> inherits from template parameter <code>T</code> or from an implementation-supplied base class that inherits from template parameter <code>T</code>.</p>
<p>[<em>Note:</em> Permitting an implementation-supplied base class gives an implementation latitude to perform empty base optimization if it so chooses. <em>-- end note</em>]</p>
<pre><code>  template &lt;Destructible T&gt;
  class basic_mixin : protected <em>see below</em> {
  public:
    // constructors 
    constexpr basic_mixin()
      noexcept(is_nothrow_default_constructible&lt;T&gt;::value)
      requires DefaultConstructible&lt;T&gt;();
    constexpr basic_mixin(const T&amp; t)
      noexcept(is_nothrow_copy_constructible&lt;T&gt;::value)
      requires CopyConstructible&lt;T&gt;();
    constexpr basic_mixin(T&amp;&amp; t)
      noexcept(is_nothrow_move_constructible&lt;T&gt;::value)
      requires MoveConstructible&lt;T&gt;();

    // T object access
    constexpr T&amp; get() &amp; noexcept;
    constexpr const T&amp; get() const&amp; noexcept;
    constexpr T&amp;&amp; get() &amp;&amp; noexcept;
    constexpr const T&amp;&amp; get() const&amp;&amp; noexcept;
  };</code></pre>
<h5 id="constructors-mixin.cons">24.8.9.2.1  Constructors [mixin.cons]</h5>
<pre><code>constexpr basic_mixin()
  noexcept(is_nothrow_default_constructible&lt;T&gt;::value)
  requires DefaultConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Default constructs an object of class <code>basic_mixin</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> <code>get()</code> returns a reference to a default constructed object or sub-object of type <code>T</code>.</p>
</blockquote>
<pre><code>constexpr basic_mixin(const T&amp; t)
  noexcept(is_nothrow_copy_constructible&lt;T&gt;::value)
  requires CopyConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Copy constructs an object of type <code>basic_mixin</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> <code>get()</code> returns a reference to a copy constructed object or sub-object of type <code>T</code> with same state as <code>t</code>.</p>
</blockquote>
<pre><code>constexpr basic_mixin(T&amp;&amp; t)
  noexcept(is_nothrow_move_constructible&lt;T&gt;::value)
  requires MoveConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Move constructs an object of type <code>basic_mixin</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> <code>get()</code> returns a reference to a move constructed object or sub-object of type <code>T</code> with the state of <code>ranges::move(t)</code>.</p>
</blockquote>
<h5 id="t-object-access-mixin.access">24.8.9.2.2  <code>T</code> object access [mixin.access]</h5>
<p>The <code>get</code> member functions are permitted return a reference to either an object or a sub-object. [<em>Note:</em> This allows an implementation to return a reference to either a data member of type T or <code>*this</code> respectively, depending on implementation details. -- <em>end note</em>]</p>
<pre><code>constexpr T&amp; get() &amp; noexcept;
constexpr const T&amp; get() const&amp; noexcept;</code></pre>
<blockquote>
<p><em>Returns:</em> A reference to the object or sub-object of type T created when <code>*this</code> was constructed.</p>
</blockquote>
<pre><code>constexpr T&amp;&amp; get() &amp;&amp; noexcept;
constexpr const T&amp;&amp; get() const&amp;&amp; noexcept;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>std::move(x)</code>, where <code>x</code> is a reference to the object or sub-object of type T created when <code>*this</code> was constructed..</p>
</blockquote>
<p><span style="background-color:lightgrey"><em>Continue to add to Basic Iterators [iterators.basic]:</em></span></p>
<h4 id="class-template-basic_iterator-iterator.basic_iterator">24.8.9.3  Class template <code>basic_iterator</code> [iterator.basic_iterator]</h4>
<p>Class template <code>basic_iterator</code> describes an iterator over a sequence. A <code>basic_iterator</code> instantiation satisfies concept <code>ranges::Iterator</code>. Which of the other iterator concepts will be satisfied is determined by which cursor concepts <span style="background-color:yellow"><em>(reference)</em></span> are satisfied by the <code>basic_iterator</code> template parameter <code>C</code>.</p>
<h5 id="synopsis-basic_iterator.synopsis">24.8.9.3.1  Synopsis [basic_iterator.synopsis]</h5>
<pre><code>namespace std {
namespace experimental {
namespace ranges {
inline namespace v1 {
  
  template &lt;Cursor C&gt;  
  class basic_iterator
    : public mixin_t&lt;C&gt;
  {
  private:
    // all private members for exposition only 
    using mixin = mixin_t&lt;C&gt;;
    using mixin::get;

    using assoc_t = <em>see below</em>;
    using typename assoc_t::postfix_increment_result_t;
    using typename assoc_t::reference_t;
    using typename assoc_t::const_reference_t;

    using difference_type = cursor::difference_type_t&lt;C&gt;;
  public:
 
    // constructors, assignments, moves, swaps
    basic_iterator() = default;

    using mixin::mixin;

    template &lt;ConvertibleTo&lt;C&gt; O&gt;
      constexpr basic_iterator(basic_iterator&lt;O&gt;&amp;&amp; that)
        noexcept(is_nothrow_constructible&lt;mixin, O&amp;&amp;&gt;::value);
    template &lt;ConvertibleTo&lt;C&gt; O&gt;
      constexpr basic_iterator(const basic_iterator&lt;O&gt;&amp; that)
        noexcept(is_nothrow_constructible&lt;mixin, const O&amp;&gt;::value);

    template &lt;ConvertibleTo&lt;C&gt; O&gt;
      constexpr basic_iterator&amp; operator=(basic_iterator&lt;O&gt;&amp;&amp; that) &amp;
        noexcept(is_nothrow_assignable&lt;C&amp;, O&amp;&amp;&gt;::value);
    template &lt;ConvertibleTo&lt;C&gt; O&gt;
      constexpr basic_iterator&amp; operator=(const basic_iterator&lt;O&gt;&amp; that) &amp;
        noexcept(is_nothrow_assignable&lt;C&amp;, const O&amp;&gt;::value);

    template &lt;class T&gt;
      requires
        !Same&lt;decay_t&lt;T&gt;, basic_iterator&gt;() &amp;&amp;
        !cursor::Next&lt;C&gt;() &amp;&amp;
        cursor::Writable&lt;C, T&gt;()
      constexpr basic_iterator&amp; operator=(T&amp;&amp; t) &amp;
        noexcept(noexcept(declval&lt;C&amp;&gt;().write(static_cast&lt;T&amp;&amp;&gt;(t))));

    friend constexpr decltype(auto) iter_move(const basic_iterator&amp; i)
        noexcept(noexcept(i.get().indirect_move()))
      requires cursor::IndirectMove&lt;C&gt;();

    template &lt;class O&gt;
      requires cursor::IndirectSwap&lt;C, O&gt;()
    friend constexpr void iter_swap(
      const basic_iterator&amp; x, const basic_iterator&lt;O&gt;&amp; y)
        noexcept(noexcept((void)x.indirect_swap(y));
    
    // dereferences
    constexpr decltype(auto) operator*() const
      noexcept(noexcept(declval&lt;const C&amp;&gt;().read()))
        requires cursor::Readable&lt;C&gt;() &amp;&amp; !detail::is_writable&lt;C&gt;;
    constexpr decltype(auto) operator*()
      noexcept(noexcept(reference_t{declval&lt;mixin&amp;&gt;().get()}))
        requires cursor::Next&lt;C&gt;() &amp;&amp; detail::is_writable&lt;C&gt;;
    constexpr decltype(auto) operator*() const
      noexcept(noexcept(
          const_reference_t{declval&lt;const mixin&amp;&gt;().get()}))
        requires cursor::Next&lt;C&gt;() &amp;&amp; detail::is_writable&lt;C&gt;;
    constexpr basic_iterator&amp; operator*() noexcept
      requires !cursor::Next&lt;C&gt;();

    // operator-&gt;: &quot;Manual&quot; deduction override,
    constexpr decltype(auto) operator-&gt;() const
      noexcept(noexcept(declval&lt;const C&amp;&gt;().arrow()))
        requires cursor::Arrow&lt;C&gt;();
    // operator-&gt;: Otherwise, if reference_t is an lvalue reference,
    constexpr auto operator-&gt;() const
      noexcept(noexcept(*declval&lt;const basic_iterator&amp;&gt;()))
        requires cursor::Readable&lt;C&gt;() &amp;&amp; !cursor::Arrow&lt;C&gt;()
          &amp;&amp; is_lvalue_reference&lt;const_reference_t&gt;::value;
    // operator-&gt;: Otherwise, deduce if needed
    constexpr auto operator-&gt;() const
      noexcept(is_nothrow_move_constructible&lt;
               detail::operator_arrow_proxy&lt;basic_iterator&gt;&gt;::value &amp;&amp;
             noexcept(detail::operator_arrow_proxy&lt;basic_iterator&gt;{
                        *declval&lt;const basic_iterator&amp;&gt;()}))
      requires cursor::Readable&lt;C&gt;() &amp;&amp; !cursor::Arrow&lt;C&gt;()
        &amp;&amp; !is_reference&lt;const_reference_t&gt;::value;
         
    // modifiers
    constexpr basic_iterator&amp; operator++() &amp; noexcept;
    constexpr basic_iterator&amp; operator++() &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().next()))
      requires cursor::Next&lt;C&gt;();

    constexpr postfix_increment_result_t operator++(int) &amp;
      noexcept(is_nothrow_constructible&lt;postfix_increment_result_t,
        basic_iterator&amp;&gt;::value
        &amp;&amp; is_nothrow_move_constructible&lt;postfix_increment_result_t&gt;::value
        &amp;&amp; noexcept(++declval&lt;basic_iterator&amp;&gt;()));

    constexpr basic_iterator&amp; operator--() &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().prev()))
      requires cursor::Bidirectional&lt;C&gt;();

    constexpr basic_iterator operator--(int) &amp;
      noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             noexcept(--declval&lt;basic_iterator&amp;&gt;()))
      requires cursor::Bidirectional&lt;C&gt;();

    constexpr basic_iterator&amp; operator+=(difference_type n) &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().advance(n)))
      requires cursor::RandomAccess&lt;C&gt;();

    constexpr basic_iterator&amp; operator-=(difference_type n) &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().advance(-n)))
      requires cursor::RandomAccess&lt;C&gt;();
    
    constexpr decltype(auto) operator[](difference_type n) const
      noexcept(noexcept(*(declval&lt;basic_iterator&amp;&gt;() + n)))
      requires cursor::RandomAccess&lt;C&gt;();

    // non-template type-symmetric ops to enable implicit conversions
    friend constexpr difference_type operator-(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(y.get().distance_to(x.get())))
      requires cursor::SizedSentinel&lt;C, C&gt;();
    friend constexpr bool operator==(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(x.get().equal(y.get())))
      requires cursor::Sentinel&lt;C, C&gt;();
    friend constexpr bool operator!=(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(!(x == y)))
      requires cursor::Sentinel&lt;C, C&gt;();
    friend constexpr bool operator&lt;(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(x - y))
      requires cursor::SizedSentinel&lt;C, C&gt;();
    friend constexpr bool operator&gt;(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(x - y))
      requires cursor::SizedSentinel&lt;C, C&gt;();
    friend constexpr bool operator&lt;=(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(x - y))
      requires cursor::SizedSentinel&lt;C, C&gt;();
    friend constexpr bool operator&gt;=(
        const basic_iterator&amp; x, const basic_iterator&amp; y)
      noexcept(noexcept(x - y))
      requires cursor::SizedSentinel&lt;C, C&gt;();
  };
  
  // basic_iterator nonmember traits
  template &lt;class C&gt;
    struct difference_type&lt;basic_iterator&lt;C&gt;&gt;
      { using type = cursor::difference_type_t&lt;C&gt;; };
  template &lt;cursor::Input C&gt;
    struct iterator_category&lt;basic_iterator&lt;C&gt;&gt;
      { using type = cursor::category_t&lt;C&gt;; };
  template &lt;cursor::Input C&gt;
    struct value_type&lt;basic_iterator&lt;C&gt;&gt;
      { using type = cursor::value_type_t&lt;C&gt;; };
   
  // basic_iterator nonmember functions
  template &lt;_InstanceOf&lt;basic_iterator&gt; BI&gt;
    constexpr decltype(auto) get_cursor(BI&amp;&amp; i)
      noexcept(noexcept(std::forward&lt;BI&gt;(i).get()));

  template &lt;class C&gt;
  constexpr basic_iterator&lt;C&gt; operator+(
      const basic_iterator&lt;C&gt;&amp; i, cursor::difference_type_t&lt;C&gt; n)
    noexcept(is_nothrow_copy_constructible&lt;basic_iterator&lt;C&gt;&gt;::value &amp;&amp;
         is_nothrow_move_constructible&lt;basic_iterator&lt;C&gt;&gt;::value &amp;&amp;
         noexcept(declval&lt;basic_iterator&lt;C&gt;&amp;&gt;() += n))
    requires cursor::RandomAccess&lt;C&gt;();
  template &lt;class C&gt;
  constexpr basic_iterator&lt;C&gt; operator+(
      cursor::difference_type_t&lt;C&gt; n, const basic_iterator&lt;C&gt;&amp; i)
    noexcept(noexcept(i + n))
    requires cursor::RandomAccess&lt;C&gt;();

  template &lt;class C&gt;
  constexpr basic_iterator&lt;C&gt; operator-(
      const basic_iterator&lt;C&gt;&amp; i, cursor::difference_type_t&lt;C&gt; n)
    noexcept(noexcept(i + -n))
    requires cursor::RandomAccess&lt;C&gt;();
  template &lt;class C1, class C2&gt;
    requires cursor::SizedSentinel&lt;C1, C2&gt;()
  constexpr cursor::difference_type_t&lt;C2&gt; operator-(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(
      ranges::get_cursor(rhs).distance_to(ranges::get_cursor(lhs))));
  template &lt;class C, class S&gt;
    requires cursor::SizedSentinel&lt;S, C&gt;()
  constexpr difference_type_t&lt;C&gt; operator-(
      const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
    noexcept(noexcept(ranges::get_cursor(rhs).distance_to(lhs)));
  template &lt;class C, class S&gt;
    requires cursor::SizedSentinel&lt;S, C&gt;()
  constexpr difference_type_t&lt;C&gt; operator-(
      const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
    noexcept(noexcept(-(rhs - lhs)));

  template &lt;class C1, class C2&gt;
    requires cursor::Sentinel&lt;C2, C1&gt;()
  constexpr bool operator==(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(ranges::get_cursor(lhs).equal(ranges::get_cursor(rhs));
  template &lt;class C, class S&gt;
    requires cursor::Sentinel&lt;S, C&gt;()
  constexpr bool operator==(
      const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
    noexcept(noexcept(ranges::get_cursor(lhs).equal(rhs)));
  template &lt;class C, class S&gt;
    requires cursor::Sentinel&lt;S, C&gt;()
  constexpr bool operator==(
      const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
    noexcept(noexcept(rhs == lhs));

  template &lt;class C1, class C2&gt;
    requires cursor::Sentinel&lt;C2, C1&gt;()
  constexpr bool operator!=(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(!(lhs == rhs)));
  template &lt;class C, class S&gt;
    requires cursor::Sentinel&lt;S, C&gt;()
  constexpr bool operator!=(
      const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
    noexcept(noexcept(!ranges::get_cursor(lhs).equal(rhs)));
  template &lt;class C, class S&gt;
    requires cursor::Sentinel&lt;S, C&gt;()
  constexpr bool operator!=(
      const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
    noexcept(noexcept(!ranges::get_cursor(rhs).equal(lhs)));

  template &lt;class C1, class C2&gt;
    requires cursor::SizedSentinel&lt;C1, C2&gt;()
  constexpr bool operator&lt;(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(lhs - rhs &lt; 0));

  template &lt;class C1, class C2&gt;
    requires cursor::SizedSentinel&lt;C1, C2&gt;()
  constexpr bool operator&gt;(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(lhs - rhs &gt; 0));

  template &lt;class C1, class C2&gt;
    requires cursor::SizedSentinel&lt;C1, C2&gt;()
  constexpr bool operator&lt;=(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(lhs - rhs &lt;= 0));

  template &lt;class C1, class C2&gt;
    requires cursor::SizedSentinel&lt;C1, C2&gt;()
  constexpr bool operator&gt;=(
      const basic_iterator&lt;C1&gt;&amp; lhs, const basic_iterator&lt;C2&gt;&amp; rhs)
    noexcept(noexcept(lhs - rhs &gt;= 0));
}}}}</code></pre>
<h5 id="requirements-basic_iterator.require">24.8.9.3.2  Requirements [basic_iterator.require]</h5>
<p>Private members of class <code>basic_iterator</code> are for exposition only (C++17 17.5.2.3 Private members [objects.within.classes]).</p>
<pre><code>using mixin = mixin_t&lt;C&gt;;
using mixin::get;</code></pre>
<blockquote>
<p><em>Remarks:</em> Provides access to the <code>get</code> functions described in <a href="#t-object-access-mixin.access">mixin object access [mixin.object]</a>.</p>
</blockquote>
<pre><code>using assoc_t = <em>see below</em>;</code></pre>
<blockquote>
<p><em>Remarks:</em> <code>assoc_t</code> is an alias for an unspecified type containing several implementation-supplied types.</p>
</blockquote>
<pre><code>using typename assoc_t::postfix_increment_result_t;</code></pre>
<blockquote>
<p><em>Remarks:</em> If <code>cursor::Next&lt;C&gt;</code> is satisfied, <code>postfix_increment_result_t</code> shall satisfy the requirements imposed by <a href="#op-pos-inc"><code>operator++(int)</code> below</a> and concept <code>WeaklyIncrementable&lt;basic_iterator&lt;C&gt;&gt;</code> (RangesTS[iterators.weaklyincrementable]). If <code>cursor::Next&lt;C&gt;</code> is not satisfied, <code>postfix_increment_result_t</code> has no requirements.</p>
</blockquote>
<pre><code>using typename assoc_t::reference_t;</code></pre>
<p><span style="background-color:yellow"><em>TBS</em></span></p>
<pre><code>using typename assoc_t::const_reference_t;</code></pre>
<p><span style="background-color:yellow"><em>TBS</em></span></p>
<pre><code>using difference_type = cursor::difference_type_t&lt;C&gt;;</code></pre>
<p><span style="background-color:yellow"><em>TBS</em></span></p>
<h5 id="constructors-assignments-and-moves-basic_iterator.cons">24.8.9.3.3  Constructors, assignments, and moves [basic_iterator.cons]</h5>
<pre><code>template &lt;ConvertibleTo&lt;C&gt; O&gt;
  constexpr basic_iterator(const basic_iterator&lt;O&gt;&amp; that)
    noexcept(is_nothrow_constructible&lt;mixin, const O&amp;&gt;::value);</code></pre>
<blockquote>
<p><em>Effects:</em> Constructs an object of class <code>basic_iterator</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> The state of <code>*this</code> is the same as <code>that</code>.</p>
</blockquote>
<pre><code>template &lt;ConvertibleTo&lt;C&gt; O&gt;
  constexpr basic_iterator(basic_iterator&lt;O&gt;&amp;&amp; that)
    noexcept(is_nothrow_constructible&lt;mixin, O&amp;&amp;&gt;::value);</code></pre>
<blockquote>
<p><em>Effects:</em> Constructs an object of class <code>basic_iterator</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> The state of <code>*this</code> is the same as the initial state of <code>that</code>. <code>that</code> is in a valid but unspecified state.</p>
</blockquote>
<pre><code>template &lt;ConvertibleTo&lt;C&gt; O&gt;
  constexpr basic_iterator&amp; operator=(const basic_iterator&lt;O&gt;&amp; that) &amp;
    noexcept(is_nothrow_assignable&lt;C&amp;, const O&amp;&gt;::value);</code></pre>
<blockquote>
<p><em>Effects:</em> If <code>*this</code> and <code>that</code> are not the same object, copy assigns <code>that</code> to <code>*this</code>. Otherwise no effect.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> The state of <code>*this</code> is the same as <code>that</code>.</p>
</blockquote>
<pre><code>template &lt;ConvertibleTo&lt;C&gt; O&gt;
  constexpr basic_iterator&amp; operator=(basic_iterator&lt;O&gt;&amp;&amp; that) &amp;
    noexcept(is_nothrow_assignable&lt;C&amp;, O&amp;&amp;&gt;::value);</code></pre>
<blockquote>
<p><em>Effects:</em> Move assigns <code>that</code> to <code>*this</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> The state of <code>*this</code> is the same as the initial state of <code>that</code>. <code>that</code> is left in a valid but unspecified state.</p>
</blockquote>
<pre><code>template &lt;class T&gt;
  requires
    !Same&lt;decay_t&lt;T&gt;, basic_iterator&gt;() &amp;&amp;
    !cursor::Next&lt;C&gt;() &amp;&amp;
    cursor::Writable&lt;C, T&gt;()
  constexpr basic_iterator&amp; operator=(T&amp;&amp; t) &amp;
    noexcept(noexcept(declval&lt;C&amp;&gt;().write(static_cast&lt;T&amp;&amp;&gt;(t))));</code></pre>
<blockquote>
<p><em>Effects:</em> Move assigns <code>t</code> to <code>*this</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<blockquote>
<p><em>Postconditions:</em> The state of <code>*this</code> is the same as the initial state of <code>t</code>. <code>t</code> is left in a valid but unspecified state.</p>
</blockquote>
<pre><code>friend constexpr decltype(auto) iter_move(const basic_iterator&amp; i)
    noexcept(noexcept(i.get().indirect_move()))
  requires cursor::IndirectMove&lt;C&gt;();</code></pre>
<p><span style="background-color:yellow"><em>Help needed!</em></span></p>
<pre><code>template &lt;class O&gt;
  requires cursor::IndirectSwap&lt;C, O&gt;()
friend constexpr void iter_swap(
  const basic_iterator&amp; x, const basic_iterator&lt;O&gt;&amp; y)
    noexcept(noexcept((void)x.indirect_swap(y));</code></pre>
<p><span style="background-color:yellow"><em>Help needed!</em></span></p>
<h5 id="dereferences-basic_iterator.deref">24.8.9.3.4  Dereferences [basic_iterator.deref]</h5>
<pre><code>constexpr decltype(auto) operator*() const
  noexcept(noexcept(declval&lt;const C&amp;&gt;().read()));</code></pre>
<blockquote>
<p><em>Returns:</em> <code>get().read()</code>.</p>
</blockquote>
<blockquote>
<p><em>Remarks:</em> <code>get().read()</code> requires <code>requires(C&amp; c) { c.read(); }</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator*() noexcept
  requires cursor::is_writable&lt;C&gt;;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>reference_t{get()}</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator*() const noexcept
  requires cursor::is_writable&lt;C&gt;;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>const_reference_t{get()}</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator-&gt;() const
  noexcept(noexcept(declval&lt;const C&amp;&gt;().arrow()))
  requires cursor::Arrow&lt;const C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>get().arrow()</code>.</p>
</blockquote>
<h5 id="modifiers-basic_iterator.mods">24.8.9.3.5  Modifiers [basic_iterator.mods]</h5>
<pre><code>constexpr basic_iterator&amp; operator++() &amp; noexcept;</code></pre>
<blockquote>
<p><em>Effects:</em> None.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<blockquote>
<p>[<em>Note:</em> This overload is only selected if the following overload is not selected. <em>-- end note</em>]</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator++() &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().next()))
  requires cursor::Next&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>get().next()</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator++(int) &amp; noexcept;</code></pre>
<blockquote>
<p><em>Effects:</em> None.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<blockquote>
<p>[<em>Note:</em> This overload is only selected if the following overload is not selected. <em>-- end note</em>]</p>
</blockquote>
<p><a name="op-pos-inc"></a></p>
<pre><code>constexpr postfix_increment_result_t operator++(int) &amp;
  noexcept(is_nothrow_constructible&lt;postfix_increment_result_t,
    basic_iterator&amp;&gt;::value
    &amp;&amp; is_nothrow_move_constructible&lt;postfix_increment_result_t&gt;::value &amp;&amp;
         noexcept(++declval&lt;basic_iterator&amp;&gt;()))
  requires cursor::Next&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>postfix_increment_result_t tmp(*this);</code><br />
 <code>++*this;</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator--() &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().prev()))
  requires cursor::Bidirectional&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>get().prev();</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator operator--(int) &amp;
  noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         noexcept(--declval&lt;basic_iterator&amp;&gt;()))
  requires cursor::Bidirectional&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>auto tmp = *this;</code><br />
 <code>--*this;</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator+=(difference_type n) &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().advance(n)))
  requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>get().advance(n)</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator-=(difference_type n) &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().advance(-n)))
  requires cursor::RandomAccess&lt;C&gt;();  </code></pre>
<blockquote>
<p><em>Effects:</em> <code>get().advance(-n)</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator+(const basic_iterator&amp; i, difference_type n)
    noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         noexcept(declval&lt;C&amp;&gt;().advance(n)))
    requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>auto tmp = i;</code><br />
 <code>tmp.get().advance(n);</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator+(difference_type n, const basic_iterator&amp; i)
    noexcept(noexcept(i + n))
    requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>i + n</code>.</p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator-(const basic_iterator&amp; i, difference_type n)
    noexcept(noexcept(i + -n))
    requires cursor::RandomAccess&lt;C&gt;();    </code></pre>
<blockquote>
<p><em>Returns:</em> <code>i + -n</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator[](difference_type n) const
  noexcept(noexcept(*(declval&lt;basic_iterator&amp;&gt;() + n)))
  requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>*(*this + n)</code>.</p>
</blockquote>
<h5 id="basic_iterator-nonmember-functions-basic_iterator.nonmem">24.8.9.3.6  <code>basic_iterator</code> nonmember functions [basic_iterator.nonmem]</h5>
<pre><code>template &lt;class C&gt;
  constexpr C&amp; get_cursor(basic_iterator&lt;C&gt;&amp; i)
    noexcept(noexcept(i.get()))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>i.get()</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  constexpr const C&amp; get_cursor(const basic_iterator&lt;C&gt;&amp; i)
    noexcept(noexcept(i.get()))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>i.get()</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  constexpr C&amp;&amp; get_cursor(basic_iterator&lt;C&gt;&amp;&amp; i)
    noexcept(noexcept(i.get()))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>std::move(i.get())</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::Sentinel&lt;C, C&gt;()
constexpr bool operator==(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(
    static_cast&lt;bool&gt;(ranges::get_cursor(lhs).equal(ranges::get_cursor(rhs))))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>ranges::get_cursor(lhs).equal(ranges::get_cursor(rhs))</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::Sentinel&lt;S, C&gt;()
constexpr bool operator==(
  const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
  noexcept(noexcept(ranges::get_cursor(lhs).equal(rhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>ranges::get_cursor(lhs).equal(rhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::Sentinel&lt;S, C&gt;()
constexpr bool operator==(
  const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(rhs == lhs))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>rhs == lhs</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::Sentinel&lt;C, C&gt;()
constexpr bool operator!=(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(!(lhs == rhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>!(lhs == rhs</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::Sentinel&lt;S, C&gt;()
constexpr bool operator!=(
  const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
  noexcept(noexcept(!get_cursor(lhs).equal(rhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>!ranges::get_cursor(lhs).equal(rhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::Sentinel&lt;S, C&gt;()
constexpr bool operator!=(
  const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(rhs != lhs))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>rhs != lhs</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::SizedSentinel&lt;C, C&gt;()
constexpr cursor::difference_type_t&lt;C&gt; operator-(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(get_cursor(rhs).distance_to(get_cursor(lhs))))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>ranges::get_cursor(rhs).distance_to(ranges::get_cursor(lhs))</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::SizedSentinel&lt;S, C&gt;()
constexpr cursor::difference_type_t&lt;C&gt; operator-(
  const S&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(get_cursor(rhs).distance_to(lhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>get_cursor(rhs).distance_to(lhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C, class S&gt;
  requires cursor::SizedSentinel&lt;S, C&gt;()
constexpr cursor::difference_type_t&lt;C&gt; operator-(
  const basic_iterator&lt;C&gt;&amp; lhs, const S&amp; rhs)
  noexcept(noexcept(-(rhs - lhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>-(rhs - lhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::SizedSentinel&lt;C, C&gt;()
constexpr bool operator&lt;(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(0 &lt; get_cursor(rhs).distance_to(lhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>0 &lt; ranges::get_cursor(rhs).distance_to(lhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::SizedSentinel&lt;C, C&gt;()
constexpr bool operator&gt;(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(rhs &lt; lhs))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>rhs &lt; lhs</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::SizedSentinel&lt;C, C&gt;()
constexpr bool operator&lt;=(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(!(rhs &lt; lhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>!(rhs &lt; lhs)</code>.</p>
</blockquote>
<pre><code>template &lt;class C&gt;
  requires cursor::SizedSentinel&lt;C, C&gt;()
constexpr bool operator&gt;=(
  const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
  noexcept(noexcept(!(lhs &lt; rhs)))</code></pre>
<blockquote>
<p><em>Returns:</em> <code>!(lhs &lt; rhs)</code>.</p>
</blockquote>
<!-- generate-section-numbers=false -->
<h2 id="open-questions">Open questions</h2>
<p><strong>Is the target C++17 or the the Ranges TS?</strong> Deferred until the committee decides if the Concepts TS and Ranges TS are included in C++17.</p>
<p><strong>Should the class template <code>basic_mixin</code> be added to 20 &quot;General utilities&quot; or 24 &quot;Iterators&quot;?</strong> The proposed wording adds it to &quot;Iterators&quot;, but there is nothing iterator specific in its design or description, and it is generally useful across multiple problem domains. LEWG input would be helpful.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p><em>TBS</em></p>
<h2 id="references">References</h2>
<p>[<a name="1">1</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="https://www.boost.org/doc/libs/1_59_0/libs/iterator/doc/iterator_facade.html">Boost Iterator Facade</a>, 2003.</p>
<p>[<a name="2">2</a>] Chandler Carruth, <a href="https://github.com/llvm-mirror/llvm/blob/master/include/llvm/ADT/iterator.h">LLVM <code>iterator_facade_base</code> iterator.h</a>, 2014.</p>
<p>[<a name="3">3</a>] Andrew Sutton, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">N4553, Working Draft, C++ extensions for Concepts</a>, 2015.</p>
<p>[<a name="4">4</a>] Eric Niebler, Casey Carter, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">N4650, Working Draft, C++ Extensions for Ranges</a>, 2015.</p>
<p>[<a name="5">5</a>] Eric Niebler, Casey Carter, <a href="https://github.com/ericniebler/range-v3">Experimental range library for C++11/14/17</a>, 2015. Requires a C++14 compiler. Simulates concepts with macros and templates.</p>
<p>[<a name="6">6</a>] Casey Carter, Eric Niebler, <a href="https://github.com/CaseyCarter/cmcstl2">An implementation of C++ Extensions for Ranges</a>, 2015. Requires a C++14 compiler supporting concepts (e.g. GCC trunk).</p>
<p>[<a name="7">7</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1641.html">N1641, Iterator Facade and Adaptor</a>, 2004.</p>
<p>[<a name="8">8</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1640.html">N1640, New Iterator Concepts</a>, 2004.</p>
<hr />
</body>
</html>
