<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#iterator-facade-library-proposal-for-ranges">Iterator Facade Library Proposal for Ranges</a><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
<li><a href="#proposal">Proposal</a></li>
<li><a href="#history">History</a></li>
</ul></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#design-decisions">Design Decisions</a><ul>
<li><a href="#use-boost-iterator_facade-as-a-role-model">Use Boost <code>iterator_facade</code> as a role model</a></li>
<li><a href="#base-the-interface-on-features-in-the-concepts-ts-and-the-ranges-ts-working-paper">Base the interface on features in the Concepts TS and the Ranges TS working paper</a></li>
<li><a href="#use-cursor-mixins-to-supply-implementation-details">Use Cursor mixins to supply implementation details</a></li>
</ul></li>
<li><a href="#proposed-wording">Proposed wording</a><ul>
<li><a href="#method-of-description-informative">Method of description (Informative)</a></li>
<li><a href="#basic-iterators-iterator.basic">Basic iterators [iterator.basic]</a></li>
<li><a href="#namespace-cursor-namespace.cursor">Namespace cursor [<a name="namespace-cursor">namespace.cursor</a>]</a></li>
<li><a href="#namespace-cursor-synopsis">Namespace cursor synopsis</a></li>
<li><a href="#namespace-cursor-semantics">Namespace cursor semantics</a></li>
<li><a href="#class-template-basic_mixin-iterator.mixin">Class template <code>basic_mixin</code> [<a name="iterator-mixin">iterator.mixin</a>]</a></li>
<li><a href="#class-template-basic_iterator">Class template <code>basic_iterator</code></a></li>
<li><a href="#requirements-basic_iterator.require">Requirements [basic_iterator.require]</a></li>
<li><a href="#types-basic_iterator.types">Types [basic_iterator.types]</a></li>
<li><a href="#constructors-assignments-and-moves-basic_iterator.cons">Constructors, assignments, and moves [basic_iterator.cons]</a></li>
<li><a href="#dereferences-basic_iterator.deref">Dereferences [basic_iterator.deref]</a></li>
<li><a href="#modifiers-basic_iterator.mods">Modifiers [basic_iterator.mods]</a></li>
<li><a href="#basic_iterator-nonmember-functions-basic_iterator.nonmem"><code>basic_iterator nonmember</code> functions [basic_iterator.nonmem]</a></li>
</ul></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ul></li>
</ul>
</div>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left">D0186R0</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2015-12-20</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">To be decided</td>
</tr>
<tr>
  <td align="left" valign="top">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;</br>
    Eric Niebler &lt;....&gt;</br>
    Casey Carter &lt;....&gt;</td>
</tr>
</table>
<h1 id="iterator-facade-library-proposal-for-ranges">Iterator Facade Library Proposal for Ranges</h1>
<p><span style="background-color:lightyellow"><strong><em>This is the &quot;no-access&quot; branch, an experiment to see if removing mention of class <code>access</code> (i.e. considering it an implementation detail) results in a less confusing specification.</em></strong></span></p>
<p><em>&quot;We are what we pretend to be, so we must be careful about what we pretend to be.&quot; - Kurt Vonnegut</em></p>
<blockquote>
<p><strong>Summary:</strong> Proposes a library component for easily creating conforming iterators. Based on existing practice. Depends only on the C++17 working paper plus Concepts TS and Ranges TS. Breaks no existing code or ABI's. Two open-source implementations with test suites available. Draft wording provided.</p>
</blockquote>
<h2 id="table-of-contents">Table of Contents</h2>
<p><em>TBS</em></p>
<h2 id="introduction">Introduction</h2>
<h3 id="problem">Problem</h3>
<p>Iterators that conform to the requirements of the C++ standard library are tedious to write and difficult to write correctly. They are tedious to write because although they need only a few core functions, they also need subsidiary types, functions, and other boilerplate. Conforming iterators are difficult to write correctly because each iterator category has a subtly differing set of requirements, making it all too easy to get subsidiary types, functions, or other boilerplate wrong.</p>
<h3 id="solution">Solution</h3>
<p>A class template that is given a few implementation functions can generate the facade (i.e. public interface and private implementation) for a fully conforming iterator, including all boilerplate. Boost <code>iterator_facade</code> pioneered this approach and has been in wide use since 2001<sup>[<a href="#1">1</a>]</sup>. It eases writing conforming iterators and has proven less error prone than hand-coded iterators. The generated iterator conforms to an extended set of requirements based on the C++98 iterator requirements. Others, such as Chandler Carruth's LLVM <code>iterator_facade_base</code><sup>[<a href="#2">2</a>]</sup>, have provided similar classes inspired by the Boost library.</p>
<h3 id="proposal">Proposal</h3>
<p>This paper proposes an iterator facade class template for the standard library, useful by any programmer (novice, experienced, or expert) wishing to easily create a conforming iterator. The proposal uses C++11/14/17 with concepts<sup>[<a href="#3">3</a>]</sup> and ranges<sup>[<a href="#4">4</a>]</sup> to allow straightforward specification and implementation, and to ensure that the generated iterator is actually conforming. The proposal breaks no existing code and breaks no existing ABI's. Two open-source implementations with test suites are available on GitHub<sup>[<a href="#5">5</a>][<a href="#6">6</a>]</sup>.</p>
<p>The proposal is suitable for C++17 if C++17 includes concepts and ranges. Otherwise, the proposal is suitable for the Ranges TS. No other core language or library changes are required.</p>
<h3 id="history">History</h3>
<p>A 2004 proposal<sup>[<a href="#7">7</a>]</sup> based on Boost <code>iterator_facade</code> failed because it depended on an iterator update proposal<sup>[<a href="#8">8</a>]</sup> that failed because without concepts the language was not rich enough to express the necessary iterator requirements.</p>
<h2 id="examples">Examples</h2>
<p><em>TBS</em></p>
<h2 id="design-decisions">Design Decisions</h2>
<h4 id="use-boost-iterator_facade-as-a-role-model">Use Boost <code>iterator_facade</code> as a role model</h4>
<p>This ensures that the proposal represents existing practice in widespread use.</p>
<h4 id="base-the-interface-on-features-in-the-concepts-ts-and-the-ranges-ts-working-paper">Base the interface on features in the Concepts TS and the Ranges TS working paper</h4>
<p>This eliminates the difficulties with specification that bedeviled the 2004 proposal. It allows an interface specification that ensures that the resulting iterator is actually conforming. It improves error message quality when a user makes a mistake.</p>
<h4 id="use-cursor-mixins-to-supply-implementation-details">Use Cursor mixins to supply implementation details</h4>
<p>Cursor mixins have proven themselves useful time and again. That said, it's a curiously indirect way of defining an iterator's interface. The alternative of inheriting directly from the Cursor leads to interface pollution. Cursors are implementation details and they should stay hidden.</p>
<h2 id="proposed-wording">Proposed wording</h2>
<p><span style="background-color:lightgrey"><em>Editorial comments are shown in italics with a light grey background.</em></span></p>
<p><span style="background-color:lightgrey"><em>Proposed wording is relative to the Working Draft, C++ Extensions for Ranges</em></span></p>
<p><span style="background-color:lightgrey"><em>For brevity, clarity, and reduced specification errors, add the following at a location to be determined by the project editor:</em></span></p>
<h4 id="method-of-description-informative">Method of description (Informative)</h4>
<p>Simple concepts that require no further description are defined entirely in the appropriate synopsis and no further description is provided.</p>
<p>Namespaces with names reserved to the implementation are for the sake of exposition only. Implementations are not required to provide the concepts declared in these namespaces. Implementations are permitted to elide use of such exposition only concepts as long as the requirements the concepts describe are met by some other mechanism.</p>
<blockquote>
<p>[Note: This constitutes an &quot;as if&quot; rule for exposition-only concepts that allows implementations freedom to refactor such concepts or use other mechanisms, such as template metaprogramming, as long as the requirements imposed are met. -- end note]</p>
</blockquote>
<p><span style="background-color:lightgrey"><em>Add to 24.8, Iterator adaptors [iterators.predef]:</em></span></p>
<p>Iterator adaptors generate new iterator types from existing types.</p>
<p><span style="background-color:lightgrey"><em>Add a new iterator adapter at the end of 24.8, Iterator adaptors [iterators.predef]</em></span></p>
<h4 id="basic-iterators-iterator.basic">Basic iterators [iterator.basic]</h4>
<p>Class template <code>basic_iterator</code> is an iterator adaptor that iterates over the sequence described by a cursor type. <a href="#namespace-cursor">Namespace <code>cursor</code></a> provides classes, types, concepts, and traits used to create cursor types.</p>
<p>A cursor <code>C</code> may extend the interface of <code>basic_iterator&lt;C&gt;</code> by defining a nested mixin type <code>C::mixin</code>. In that way, the author of a cursor can non-intrusively add members and constructors to <code>basic_iterator</code>.</p>
<p><a href="#iterator-mixin">Class template <code>basic_mixin</code></a> supports the creation of mixin types.</p>
<blockquote>
<p>[Note: Mixin types add interface to types that inherit from them. They can also hold an object -- in this case a cursor. By publicly inheriting from a mixin type, <code>basic_iterator</code> gets: (a) a cursor data member, and, optionally, (b) additional members and constructors. -- end note]</p>
</blockquote>
<h4 id="namespace-cursor-namespace.cursor">Namespace cursor [<a name="namespace-cursor">namespace.cursor</a>]</h4>
<p>Namespace <code>cursor</code> provides a scope for the class, type, concept, and trait identifiers used to create cursor types.</p>
<h4 id="namespace-cursor-synopsis">Namespace cursor synopsis</h4>
<pre><code>  namespace cursor {

    // types
    template &lt;class C&gt;
      using reference_t = <em>see below</em>;
    template &lt;class C&gt;
      using rvalue_reference_t = <em>see below</em>;
    template &lt;class C&gt;
      using value_type_t = <em>see below</em>;
    template &lt;class C&gt;
      using difference_type_t = <em>see below</em>;
      
    // concepts
    template &lt;class C&gt;
      concept bool Cursor();
    template &lt;class C&gt;
      concept bool Input()
        { return Cursor&lt;C&gt;() &amp;&amp; Readable&lt;C&gt;() &amp;&amp; Next&lt;C&gt;(); }
    template &lt;class C&gt;
      concept bool Forward();
    template &lt;class C&gt;
      concept bool Bidirectional()
        { return Forward&lt;C&gt;() &amp;&amp; Prev&lt;C&gt;(); }
    template &lt;class C&gt;
      concept bool RandomAccess()
        { return Bidirectional&lt;C&gt;() &amp;&amp; Advance&lt;C&gt;() &amp;&amp; Distance&lt;C, C&gt;(); }
    template &lt;class C&gt;
      concept bool Contiguous();
    template &lt;class C&gt;
      concept bool Readable();
    template &lt;class C, class T&gt;
      concept bool Writable();
    template &lt;class C&gt;
      concept bool Arrow();
    template &lt;class C&gt;
      concept bool Next();
    template &lt;class C&gt;
      concept bool Prev();
    template &lt;class C&gt;
      concept bool Advance();
    template &lt;class C, class O&gt;
      concept bool Distance();
    template &lt;class C, class O&gt;
      concept bool HasEqual();

    // category traits 
    template &lt;class&gt; struct category {};
    template &lt;Input C&gt;
      struct category&lt;C&gt; { using type = input_iterator_tag; };
    template &lt;Forward C&gt;
      struct category&lt;C&gt; { using type = forward_iterator_tag; };
    template &lt;Bidirectional C&gt;
      struct category&lt;C&gt; { using type = bidirectional_iterator_tag; };
    template &lt;RandomAccess C&gt;
      struct category&lt;C&gt; { using type = random_access_iterator_tag; };
    template &lt;Contiguous C&gt;
      struct category&lt;C&gt; { using type = ext::contiguous_iterator_tag; };
    template &lt;class C&gt;
      using category_t = typename category&lt;C&gt;::type;
  }  // namespace cursor</code></pre>
<h4 id="namespace-cursor-semantics">Namespace cursor semantics</h4>
<pre><code>template &lt;class C&gt;
concept bool Cursor();</code></pre>
<p><code>Cursor&lt;C&gt;()</code> is satisfied if and only if <code>Semiregular&lt;C&gt;() &amp;&amp; Semiregular&lt;Mx&gt;()</code> is <code>true</code>, where type <code>Mx</code> is deduced by the implementation to be <code>C::mixin</code> if member <code>C::mixin</code> is present, otherwise is deduced to be <code>basic_mixin&lt;C&gt;</code>.</p>
<pre><code>template &lt;class C&gt;
concept bool Forward();</code></pre>
<p><code>Forward&lt;C&gt;</code> is satisfied if and only if <code>Input&lt;C&gt;()</code> <code>&amp;&amp; EqualityComparable&lt;C, C&gt;()</code> <code>&amp;&amp; !<em>imp</em>::single_pass&lt;C&gt;::value</code> where <code>single_pass</code> is defined as if:</p>
<blockquote>
<pre>
template &lt;class&gt;
constexpr bool single_pass = false;
template &lt;class C&gt;
  requires requires {
    typename C::single_pass;
    requires bool(C::single_pass::value);
  }
constexpr bool single_pass = true;</pre>
</blockquote>
<pre><code>    template &lt;class C&gt;
      concept bool Contiguous();</code></pre>
<p><code>Contiguous&lt;C&gt;</code> is satisfied if and only if <code>RandomAccess&lt;C&gt;()</code>, type <code>C::contiguous</code> exists, <code>C::contiguous::value == true</code>, and.</p>
<pre><code>    template &lt;class C&gt;
      concept bool Readable();</code></pre>
<p><code>Readable&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C, class T&gt;
      concept bool Writable();</code></pre>
<p><code>Writable&lt;C, T&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C&gt;
      concept bool Arrow();</code></pre>
<p><code>Arrow&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C&gt;
      concept bool Next();</code></pre>
<p><code>Next&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C&gt;
      concept bool Prev();</code></pre>
<p><code>Prev&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C&gt;
      concept bool Advance();</code></pre>
<p><code>Advance&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C, class O&gt;
      concept bool Distance();</code></pre>
<p><code>Distance&lt;C&gt;</code> is satisfied if and only if</p>
<pre><code>    template &lt;class C, class O&gt;
      concept bool HasEqual();</code></pre>
<p><code>HasEqual&lt;C&gt;</code> is satisfied if and only if</p>
<p><span style="background-color:lightgrey"><em>Add to 24.6, Header <code>&lt;experimental/ranges/iterator&gt;</code> synopsis [iterator.synopsis] or some other synopsis:</em></span></p>
<pre><code>  // basic_mixin
  template &lt;Destructible T&gt;
  class basic_mixin;</code></pre>
<p><span style="background-color:lightgrey"><em>Add somewhere:</em></span></p>
<h4 id="class-template-basic_mixin-iterator.mixin">Class template <code>basic_mixin</code> [<a name="iterator-mixin">iterator.mixin</a>]</h4>
<p>Class template <code>basic_mixin</code> describes an empty mixin type.</p>
<pre><code>  template &lt;Destructible T&gt;
  class basic_mixin {
  public:
    constexpr basic_mixin()
      noexcept(is_nothrow_default_constructible&lt;T&gt;::value)
      requires DefaultConstructible&lt;T&gt;();
    constexpr basic_mixin(const T&amp; t)
      noexcept(is_nothrow_copy_constructible&lt;T&gt;::value)
      requires CopyConstructible&lt;T&gt;();
    constexpr basic_mixin(T&amp;&amp; t)
      noexcept(is_nothrow_move_constructible&lt;T&gt;::value)
      requires MoveConstructible&lt;T&gt;();
  };</code></pre>
<h5 id="basic_mixin-constructors-mixin.cons"><code>basic_mixin</code> constructors [mixin.cons]</h5>
<pre><code>constexpr basic_mixin()
  noexcept(is_nothrow_default_constructible&lt;T&gt;::value)
  requires DefaultConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Default constructs an object of type <code>basic_mixin</code>.</p>
</blockquote>
<pre><code>constexpr basic_mixin(const T&amp; t)
  noexcept(is_nothrow_copy_constructible&lt;T&gt;::value)
  requires CopyConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Copy constructs an object of type <code>basic_mixin</code>.</p>
</blockquote>
<pre><code>constexpr basic_mixin(T&amp;&amp; t)
  noexcept(is_nothrow_move_constructible&lt;T&gt;::value)
  requires MoveConstructible&lt;T&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> Move constructs an object of type <code>basic_mixin</code>.</p>
</blockquote>
<h4 id="class-template-basic_iterator">Class template <code>basic_iterator</code></h4>
<p>Class template <code>basic_iterator</code> describes an iterator over a sequence. A type satisfying the Cursor requirements provides the sequence.</p>
<pre><code>namespace std { namespace experimental { namespace ranges_v1 { inline namespace v1 {
  
  template &lt;Cursor C&gt;  
  class basic_iterator
  : public cursor::mixin_t&lt;C&gt;  // TODO: move mixin_t&lt;&gt; from cursor::access to cursor
  {
    // types
    using difference_type = cursor::difference_type_t&lt;C&gt;;
    
    // constructors, assignments, and moves
    basic_iterator() = default;
    using mixin_t::mixin_t;
    template &lt;ConvertibleTo&lt;C&gt; O&gt;
    constexpr basic_iterator(basic_iterator&lt;O&gt; that)
      noexcept(is_nothrow_constructible&lt;mixin_t, O&amp;&amp;&gt;::value);
    friend constexpr decltype(auto) iter_move(const basic_iterator&amp; i)
      noexcept(cur().move(i.cur()))
      requires cursor::Readable&lt;C&gt;() &amp;&amp; cursor::Move&lt;C&gt;();
    
    // dereferences
    constexpr decltype(auto) operator*() const
      noexcept(noexcept(declval&lt;const C&amp;&gt;().read()))
    constexpr decltype(auto) operator*() noexcept
      requires cursor::is_writable&lt;C&gt;;
    constexpr decltype(auto) operator*() const noexcept
      requires cursor::is_writable&lt;C&gt;;
    constexpr decltype(auto) operator-&gt;() const
      noexcept(noexcept(declval&lt;const C&amp;&gt;().arrow()))
      requires cursor::Arrow&lt;const C&gt;();
         
    // modifiers
    constexpr basic_iterator&amp; operator++() &amp; noexcept;
    constexpr basic_iterator&amp; operator++() &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().next()))
      requires cursor::Next&lt;C&gt;();
    constexpr basic_iterator&amp; operator++(int) &amp; noexcept;
    constexpr postfix_increment_result_t operator++(int) &amp;
      noexcept(is_nothrow_constructible&lt;postfix_increment_result_t,
        basic_iterator&amp;&gt;::value
        &amp;&amp; is_nothrow_move_constructible&lt;postfix_increment_result_t&gt;::value &amp;&amp;
             noexcept(++declval&lt;basic_iterator&amp;&gt;()))
      requires cursor::Next&lt;C&gt;();
    constexpr basic_iterator&amp; operator--() &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().prev()))
      requires cursor::Bidirectional&lt;C&gt;();
    constexpr basic_iterator operator--(int) &amp;
      noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             noexcept(--declval&lt;basic_iterator&amp;&gt;()))
      requires cursor::Bidirectional&lt;C&gt;();
    constexpr basic_iterator&amp; operator+=(difference_type n) &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().advance(n)))
      requires cursor::RandomAccess&lt;C&gt;();
    constexpr basic_iterator&amp; operator-=(difference_type n) &amp;
      noexcept(noexcept(declval&lt;C&amp;&gt;().advance(-n)))
      requires cursor::RandomAccess&lt;C&gt;();  
    friend constexpr basic_iterator
      operator+(const basic_iterator&amp; i, difference_type n)
        noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
             noexcept(declval&lt;C&amp;&gt;().advance(n)))
        requires cursor::RandomAccess&lt;C&gt;();
    friend constexpr basic_iterator
      operator+(difference_type n, const basic_iterator&amp; i)
        noexcept(noexcept(i + n))
        requires cursor::RandomAccess&lt;C&gt;();
    friend constexpr basic_iterator
      operator-(const basic_iterator&amp; i, difference_type n)
        noexcept(noexcept(i + -n))
        requires cursor::RandomAccess&lt;C&gt;();    
    constexpr decltype(auto) operator[](difference_type n) const
      noexcept(noexcept(*(declval&lt;basic_iterator&amp;&gt;() + n)))
      requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<p><span style="background-color:lightgrey"><blockquote style="background-color:lightgrey"><em>We wish to hide implementation details, but since we wish to utilize the cursor type C that provides <code>basic_iterator</code>'s customization types and functions as a mixin, it becomes a practical impossibility to describe <code>basic_iterator</code> without describing at least a few implementation types and functions. These conflicting needs are resolved by supplying the types and functions as private &quot;exposition only&quot; members.</em></blockquote></span></p>
<pre><code>  private:  <em>// all private members are for exposition only</em>    
    using mixin_t = cursor::mixin_t&lt;C&gt;;
    using assoc_t = <em>see below</em>;
    using typename assoc_t::postfix_increment_result_t;
    using typename assoc_t::reference_t;
    using typename assoc_t::const_reference_t;
 
    // mixin cursor object access
    constexpr C&amp; cur() &amp;
      noexcept(noexcept(declval&lt;mixin_t&amp;&gt;().get()))
        { return mixin_t::get(); }  // returns iterator&#39;s cursor object
    constexpr const C&amp; cur() const&amp;
      noexcept(noexcept(declval&lt;const mixin_t&amp;&gt;().get()))
        { return mixin_t::get(); }  // returns iterator&#39;s cursor object
    constexpr C&amp;&amp; cur() &amp;&amp;
      noexcept(noexcept(declval&lt;mixin_t&amp;&gt;().get()))
        { return mixin_t::get(); }  // returns iterator&#39;s cursor object
  };
  
  // basic_iterator nonmember functions
  
  template &lt;class C&gt;
    requires cursor::EqualityComparable&lt;C, C&gt;()
  constexpr bool operator==(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)
    noexcept(<em>see below</em>);

  template &lt;class C, class Other&gt;
    requires cursor::EqualityComparable&lt;C, Other&gt;()
  constexpr bool operator==(
    const basic_iterator&lt;C&gt;&amp; lhs, const Other&amp; rhs)
    noexcept(<em>see below</em>);

  template &lt;class C, class Other&gt;
    requires cursor::EqualityComparable&lt;C, Other&gt;()
  constexpr bool operator==(
    const Other&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);
  
  template &lt;class C&gt;
    requires cursor::EqualityComparable&lt;C, C&gt;()
  constexpr bool operator!=(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C, class Other&gt;
    requires cursor::EqualityComparable&lt;C, Other&gt;()
  constexpr bool operator!=(
    const basic_iterator&lt;C&gt;&amp; lhs, const Other&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C, class Other&gt;
    requires cursor::EqualityComparable&lt;C, Other&gt;()
  constexpr bool operator!=(
    const Other&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C&gt;
    requires cursor::Distance&lt;C, C&gt;()
  constexpr cursor::access::difference_type_t&lt;C&gt; operator-(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C, class Other&gt;
    requires cursor::Distance&lt;C, Other&gt;()
  constexpr cursor::access::difference_type_t&lt;C&gt; operator-(
    const basic_iterator&lt;C&gt;&amp; lhs, const Other&amp; rhs)  
    noexcept(<em>see below</em>);
    
  template &lt;class C, class Other&gt;
    requires cursor::Distance&lt;C, Other&gt;()
  constexpr cursor::access::difference_type_t&lt;C&gt; operator-(
    const Other&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C&gt;
    requires cursor::Distance&lt;C, C&gt;()
  constexpr bool operator&lt;(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C&gt;
    requires cursor::Distance&lt;C, C&gt;()
  constexpr bool operator&gt;(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C&gt;
    requires cursor::Distance&lt;C, C&gt;()
  constexpr bool operator&lt;=(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);

  template &lt;class C&gt;
    requires cursor::Distance&lt;C, C&gt;()
  constexpr bool operator&gt;=(
    const basic_iterator&lt;C&gt;&amp; lhs, const basic_iterator&lt;C&gt;&amp; rhs)  
    noexcept(<em>see below</em>);
}}}}</code></pre>
<h4 id="requirements-basic_iterator.require">Requirements [basic_iterator.require]</h4>
<p>Class template <code>basic_iterator</code> publicly inherits from <code>C::mixin</code> if <code>C</code> defines a type named <code>mixin</code>, otherwise it publicly inherits from <code>basic_mixin&lt;C&gt;</code>.</p>
<p>Private members of class <code>basic_iterator</code> are for exposition only (17.5.2.3 Private members [objects.within.classes]).</p>
<p><span style="background-color:lightgrey"><em>Reference is made to 17.5.2.3 because implementations will need to rely on paragraph 3, &quot;An implementation may use any technique that provides equivalent external behavior&quot; since specifications like <code>operator*()</code> &quot;Returns: <code>cur().read()</code> may require some form of indirection in actual implementations to meet requirements.&quot;</em></span></p>
<h4 id="types-basic_iterator.types">Types [basic_iterator.types]</h4>
<pre><code>difference_type</code></pre>
<p><code>difference_type</code> is defined as:</p>
<ul>
<li><code>C::difference_type</code> if <code>C</code> has a member type <code>difference_type</code>,</li>
<li>otherwise <code>decltype(declval&lt;const C&amp;&gt;().distance_to(declval&lt;const C&amp;&gt;()))</code> if <code>C</code> has such a function,</li>
<li>otherwise <code>std::ptrdiff_t</code>.</li>
</ul>
<h4 id="constructors-assignments-and-moves-basic_iterator.cons">Constructors, assignments, and moves [basic_iterator.cons]</h4>
<p><em>TBS</em></p>
<h4 id="dereferences-basic_iterator.deref">Dereferences [basic_iterator.deref]</h4>
<pre><code>constexpr decltype(auto) operator*() const
  noexcept(noexcept(declval&lt;const C&amp;&gt;().read()));</code></pre>
<blockquote>
<p><em>Returns:</em> <code>cur().read()</code>.</p>
</blockquote>
<blockquote>
<p><em>Remarks:</em> <code>cur().read()</code> requires <code>requires(C&amp; c) { c.read(); }</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator*() noexcept
  requires cursor::is_writable&lt;C&gt;;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>reference_t{cur()}</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator*() const noexcept
  requires cursor::is_writable&lt;C&gt;;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>const_reference_t{cur()}</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator-&gt;() const
  noexcept(noexcept(declval&lt;const C&amp;&gt;().arrow()))
  requires cursor::Arrow&lt;const C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>cur().arrow()</code>.</p>
</blockquote>
<h4 id="modifiers-basic_iterator.mods">Modifiers [basic_iterator.mods]</h4>
<pre><code>constexpr basic_iterator&amp; operator++() &amp; noexcept;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator++() &amp;
  noexcept(noexcept(cursor::access::next(declval&lt;C&amp;&gt;())))
  requires cursor::Next&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>cursor::access::next(pos())</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator++(int) &amp; noexcept;</code></pre>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr postfix_increment_result_t operator++(int) &amp;
  noexcept(is_nothrow_constructible&lt;postfix_increment_result_t,
    basic_iterator&amp;&gt;::value
    &amp;&amp; is_nothrow_move_constructible&lt;postfix_increment_result_t&gt;::value &amp;&amp;
         noexcept(++declval&lt;basic_iterator&amp;&gt;()))
  requires cursor::Next&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>postfix_increment_result_t tmp(*this);</code><br />
 <code>++*this;</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator--() &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().prev()))
  requires cursor::Bidirectional&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>cur().prev();</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator operator--(int) &amp;
  noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         noexcept(--declval&lt;basic_iterator&amp;&gt;()))
  requires cursor::Bidirectional&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>auto tmp = *this;</code><br />
 <code>--*this;</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator+=(difference_type n) &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().advance(n)))
  requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em> <code>cur().advance(-n)</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>constexpr basic_iterator&amp; operator-=(difference_type n) &amp;
  noexcept(noexcept(declval&lt;C&amp;&gt;().advance(-n)))
  requires cursor::RandomAccess&lt;C&gt;();  </code></pre>
<blockquote>
<p><em>Effects:</em> <code>cur().advance(-n)</code>.</p>
</blockquote>
<blockquote>
<p><em>Returns:</em> <code>*this</code>.</p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator+(const basic_iterator&amp; i, difference_type n)
    noexcept(is_nothrow_copy_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         is_nothrow_move_constructible&lt;basic_iterator&gt;::value &amp;&amp;
         noexcept(declval&lt;C&amp;&gt;().advance(n)))
    requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Effects:</em><br />
 <code>auto tmp = i;</code><br />
 <code>tmp.cur().advance(n);</code><br />
 <code>return tmp;</code></p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator+(difference_type n, const basic_iterator&amp; i)
    noexcept(noexcept(i + n))
    requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>i + n</code>.</p>
</blockquote>
<pre><code>friend constexpr basic_iterator
  operator-(const basic_iterator&amp; i, difference_type n)
    noexcept(noexcept(i + -n))
    requires cursor::RandomAccess&lt;C&gt;();    </code></pre>
<blockquote>
<p><em>Returns:</em> <code>i + -n</code>.</p>
</blockquote>
<pre><code>constexpr decltype(auto) operator[](difference_type n) const
  noexcept(noexcept(*(declval&lt;basic_iterator&amp;&gt;() + n)))
  requires cursor::RandomAccess&lt;C&gt;();</code></pre>
<blockquote>
<p><em>Returns:</em> <code>*(*this + n)</code>.</p>
</blockquote>
<h4 id="basic_iterator-nonmember-functions-basic_iterator.nonmem"><code>basic_iterator nonmember</code> functions [basic_iterator.nonmem]</h4>
<h2 id="acknowledgements">Acknowledgements</h2>
<p><em>TBS</em></p>
<h2 id="references">References</h2>
<p>[<a name="1">1</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="https://www.boost.org/doc/libs/1_59_0/libs/iterator/doc/iterator_facade.html">Boost Iterator Facade</a>, 2003.</p>
<p>[<a name="2">2</a>] Chandler Carruth, <a href="https://github.com/llvm-mirror/llvm/blob/master/include/llvm/ADT/iterator.h">LLVM <code>iterator_facade_base</code> iterator.h</a>, 2014.</p>
<p>[<a name="3">3</a>] Andrew Sutton, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">N4553, Working Draft, C++ extensions for Concepts</a>, 2015.</p>
<p>[<a name="4">4</a>] Eric Niebler, Casey Carter, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4560.pdf">N4650, Working Draft, C++ Extensions for Ranges</a>, 2015.</p>
<p>[<a name="5">5</a>] Eric Niebler, Casey Carter, <a href="https://github.com/ericniebler/range-v3">Experimental range library for C++11/14/17</a>, 2015. Requires a C++14 compiler. Simulates concepts with macros and templates.</p>
<p>[<a name="6">6</a>] Casey Carter, Eric Niebler, <a href="https://github.com/CaseyCarter/cmcstl2">An implementation of C++ Extensions for Ranges</a>, 2015. Requires a C++14 compiler supporting concepts (e.g. GCC trunk).</p>
<p>[<a name="7">7</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1641.html">N1641, Iterator Facade and Adaptor</a>, 2004.</p>
<p>[<a name="8">8</a>] David Abrahams, Jeremy Siek, Thomas Witt, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1640.html">N1640, New Iterator Concepts</a>, 2004.</p>
<hr />
</body>
</html>
